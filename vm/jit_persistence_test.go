package vm

import (
	"bytes"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
)

func TestPersistenceMode(t *testing.T) {
	// Verify enum values
	if PersistenceNone != 0 {
		t.Error("PersistenceNone should be 0")
	}
	if PersistenceStatic != 1 {
		t.Error("PersistenceStatic should be 1")
	}
	if PersistencePlugin != 2 {
		t.Error("PersistencePlugin should be 2")
	}
	if PersistenceImage != 3 {
		t.Error("PersistenceImage should be 3")
	}
}

func TestAOTSectionMagic(t *testing.T) {
	expected := [4]byte{'A', 'O', 'T', '!'}
	if aotSectionMagic != expected {
		t.Errorf("AOT magic should be %v, got %v", expected, aotSectionMagic)
	}
}

func TestWriteForStaticBuild(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Create a test method and compile it
	class := vm.createClass("TestClass", vm.ObjectClass)
	builder := NewCompiledMethodBuilder("compute", 0)
	builder.Bytecode().EmitInt8(OpPushInt8, 42)
	builder.Bytecode().Emit(OpReturnTop)
	method := builder.Build()
	method.SetClass(class)

	// Compile the method directly
	jit.compileMethod(method)

	// Write to temp directory
	tmpDir := t.TempDir()
	err := jit.WriteForStaticBuild(tmpDir, "testaot")
	if err != nil {
		t.Fatalf("WriteForStaticBuild failed: %v", err)
	}

	// Verify file was created
	mainFile := filepath.Join(tmpDir, "aot_methods.go")
	data, err := os.ReadFile(mainFile)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	content := string(data)

	// Verify content
	if !strings.Contains(content, "package testaot") {
		t.Error("Generated file should have correct package name")
	}
	if !strings.Contains(content, "Code generated by Maggie JIT") {
		t.Error("Generated file should have generation comment")
	}
	if !strings.Contains(content, "RegisterAll") {
		t.Error("Generated file should have RegisterAll function")
	}
	if !strings.Contains(content, "TestClass") {
		t.Error("Generated file should contain TestClass")
	}
}

func TestWriteAsPlugin(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("Plugin mode not supported on Windows")
	}

	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Create and compile a test method
	class := vm.createClass("PluginTest", vm.ObjectClass)
	builder := NewCompiledMethodBuilder("run", 0)
	builder.Bytecode().Emit(OpPushNil)
	builder.Bytecode().Emit(OpReturnTop)
	method := builder.Build()
	method.SetClass(class)
	jit.compileMethod(method)

	// Write plugin source
	tmpDir := t.TempDir()
	err := jit.WriteAsPlugin(tmpDir, "testplugin")
	if err != nil {
		t.Fatalf("WriteAsPlugin failed: %v", err)
	}

	// Verify source file
	sourceFile := filepath.Join(tmpDir, "testplugin.go")
	data, err := os.ReadFile(sourceFile)
	if err != nil {
		t.Fatalf("Failed to read plugin source: %v", err)
	}

	content := string(data)

	// Verify plugin structure
	if !strings.Contains(content, "package main") {
		t.Error("Plugin should be in package main")
	}
	if !strings.Contains(content, "func RegisterAll(vm *VM)") {
		t.Error("Plugin should have exported RegisterAll function")
	}
	if !strings.Contains(content, "PluginTest") {
		t.Error("Plugin should contain PluginTest class")
	}
}

func TestWriteAsPluginWindowsError(t *testing.T) {
	if runtime.GOOS != "windows" {
		t.Skip("Test only runs on Windows")
	}

	vm := NewVM()
	jit := vm.EnableJIT()

	err := jit.WriteAsPlugin(t.TempDir(), "test")
	if err == nil {
		t.Error("WriteAsPlugin should fail on Windows")
	}
	if !strings.Contains(err.Error(), "Windows") {
		t.Error("Error message should mention Windows")
	}
}

func TestAOTEntryRoundTrip(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()

	// Create test entry
	original := AOTEntry{
		ClassName:  "MyClass",
		MethodName: "myMethod:",
		GoSource:   "func aot_MyClass_myMethod_(vm *VM, self Value, args []Value) Value { return nil }",
		Checksum:   12345,
	}

	// Write entry
	var buf bytes.Buffer
	jit.writeAOTEntry(&buf, &original)

	// Read entry back
	read, bytesRead, err := jit.readAOTEntry(buf.Bytes())
	if err != nil {
		t.Fatalf("Failed to read AOT entry: %v", err)
	}

	if bytesRead != buf.Len() {
		t.Errorf("Bytes read %d != buffer length %d", bytesRead, buf.Len())
	}

	// Verify fields
	if read.ClassName != original.ClassName {
		t.Errorf("ClassName: got %q, want %q", read.ClassName, original.ClassName)
	}
	if read.MethodName != original.MethodName {
		t.Errorf("MethodName: got %q, want %q", read.MethodName, original.MethodName)
	}
	if read.GoSource != original.GoSource {
		t.Errorf("GoSource: got %q, want %q", read.GoSource, original.GoSource)
	}
	if read.Checksum != original.Checksum {
		t.Errorf("Checksum: got %d, want %d", read.Checksum, original.Checksum)
	}
}

func TestBuildAndParseAOTSection(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Create and compile multiple methods
	class := vm.createClass("SectionTest", vm.ObjectClass)

	for i, name := range []string{"method1", "method2", "method3"} {
		builder := NewCompiledMethodBuilder(name, 0)
		builder.Bytecode().EmitInt8(OpPushInt8, int8(i+1))
		builder.Bytecode().Emit(OpReturnTop)
		method := builder.Build()
		method.SetClass(class)
		jit.compileMethod(method)
	}

	// Build section without compression
	section, err := jit.buildAOTSection(false)
	if err != nil {
		t.Fatalf("buildAOTSection failed: %v", err)
	}

	// Verify magic
	if !bytes.Equal(section[:4], aotSectionMagic[:]) {
		t.Error("Section should start with AOT magic")
	}

	// Parse section
	entries, err := jit.parseAOTSection(section)
	if err != nil {
		t.Fatalf("parseAOTSection failed: %v", err)
	}

	if len(entries) != 3 {
		t.Errorf("Expected 3 entries, got %d", len(entries))
	}

	// Verify entries
	methodNames := make(map[string]bool)
	for _, entry := range entries {
		if entry.ClassName != "SectionTest" {
			t.Errorf("Unexpected class name: %s", entry.ClassName)
		}
		methodNames[entry.MethodName] = true
	}

	for _, name := range []string{"method1", "method2", "method3"} {
		if !methodNames[name] {
			t.Errorf("Missing method: %s", name)
		}
	}
}

func TestBuildAndParseAOTSectionCompressed(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Create and compile a method with lots of code to benefit from compression
	class := vm.createClass("CompressTest", vm.ObjectClass)
	builder := NewCompiledMethodBuilder("bigMethod", 0)
	// Generate repetitive bytecode
	for i := 0; i < 100; i++ {
		builder.Bytecode().EmitInt8(OpPushInt8, int8(i%128))
		builder.Bytecode().Emit(OpPOP)
	}
	builder.Bytecode().Emit(OpReturnNil)
	method := builder.Build()
	method.SetClass(class)
	jit.compileMethod(method)

	// Build section with compression
	compressedSection, err := jit.buildAOTSection(true)
	if err != nil {
		t.Fatalf("buildAOTSection(compressed) failed: %v", err)
	}

	// Build section without compression for size comparison
	uncompressedSection, err := jit.buildAOTSection(false)
	if err != nil {
		t.Fatalf("buildAOTSection(uncompressed) failed: %v", err)
	}

	t.Logf("Compressed: %d bytes, Uncompressed: %d bytes",
		len(compressedSection), len(uncompressedSection))

	// Compressed should generally be smaller (not guaranteed for tiny data)
	// Just verify both can be parsed

	// Parse compressed section
	entries, err := jit.parseAOTSection(compressedSection)
	if err != nil {
		t.Fatalf("parseAOTSection(compressed) failed: %v", err)
	}
	if len(entries) != 1 {
		t.Errorf("Expected 1 entry from compressed, got %d", len(entries))
	}

	// Parse uncompressed section
	entries2, err := jit.parseAOTSection(uncompressedSection)
	if err != nil {
		t.Fatalf("parseAOTSection(uncompressed) failed: %v", err)
	}
	if len(entries2) != 1 {
		t.Errorf("Expected 1 entry from uncompressed, got %d", len(entries2))
	}

	// Content should match
	if entries[0].GoSource != entries2[0].GoSource {
		t.Error("Compressed and uncompressed should yield same content")
	}
}

func TestWriteToImageAndLoadFromImage(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Create and compile methods
	class := vm.createClass("ImageTest", vm.ObjectClass)

	builder1 := NewCompiledMethodBuilder("first", 0)
	builder1.Bytecode().EmitInt8(OpPushInt8, 1)
	builder1.Bytecode().Emit(OpReturnTop)
	method1 := builder1.Build()
	method1.SetClass(class)
	jit.compileMethod(method1)

	builder2 := NewCompiledMethodBuilder("second", 0)
	builder2.Bytecode().EmitInt8(OpPushInt8, 2)
	builder2.Bytecode().Emit(OpReturnTop)
	method2 := builder2.Build()
	method2.SetClass(class)
	jit.compileMethod(method2)

	// Create a minimal image file (just header + some padding)
	tmpDir := t.TempDir()
	imagePath := filepath.Join(tmpDir, "test.image")

	// Create fake image with proper header size
	fakeImage := make([]byte, ImageHeaderSize+100)
	copy(fakeImage[:4], []byte("MAGI")) // Magic
	if err := os.WriteFile(imagePath, fakeImage, 0644); err != nil {
		t.Fatalf("Failed to write fake image: %v", err)
	}

	// Write AOT to image
	err := jit.WriteToImage(imagePath, true)
	if err != nil {
		t.Fatalf("WriteToImage failed: %v", err)
	}

	// Verify image grew
	info, err := os.Stat(imagePath)
	if err != nil {
		t.Fatalf("Failed to stat image: %v", err)
	}
	if info.Size() <= int64(len(fakeImage)) {
		t.Error("Image should have grown after writing AOT section")
	}

	// Create new JIT and load from image
	vm2 := NewVM()
	jit2 := vm2.EnableJIT()

	count, err := jit2.LoadFromImage(imagePath)
	if err != nil {
		t.Fatalf("LoadFromImage failed: %v", err)
	}

	if count != 2 {
		t.Errorf("Expected to load 2 methods, got %d", count)
	}

	// Verify methods were loaded
	code := jit2.GetCompiledMethod("ImageTest", "first")
	if code == "" {
		t.Error("first method should be loaded")
	}

	code = jit2.GetCompiledMethod("ImageTest", "second")
	if code == "" {
		t.Error("second method should be loaded")
	}
}

func TestWriteToImageUpdatesExisting(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Create initial method
	class := vm.createClass("UpdateTest", vm.ObjectClass)
	builder := NewCompiledMethodBuilder("initial", 0)
	builder.Bytecode().Emit(OpReturnNil)
	method := builder.Build()
	method.SetClass(class)
	jit.compileMethod(method)

	// Create image
	tmpDir := t.TempDir()
	imagePath := filepath.Join(tmpDir, "update.image")
	fakeImage := make([]byte, ImageHeaderSize+50)
	copy(fakeImage[:4], []byte("MAGI"))
	os.WriteFile(imagePath, fakeImage, 0644)

	// Write first time
	jit.WriteToImage(imagePath, false)
	info1, _ := os.Stat(imagePath)
	size1 := info1.Size()

	// Add another method
	builder2 := NewCompiledMethodBuilder("added", 0)
	builder2.Bytecode().Emit(OpReturnNil)
	method2 := builder2.Build()
	method2.SetClass(class)
	jit.compileMethod(method2)

	// Write second time (should replace AOT section)
	jit.WriteToImage(imagePath, false)
	info2, _ := os.Stat(imagePath)
	size2 := info2.Size()

	// Second write should be larger (more methods)
	if size2 <= size1 {
		t.Error("Image should grow when more methods are added")
	}

	// Load and verify both methods present
	vm2 := NewVM()
	jit2 := vm2.EnableJIT()
	count, _ := jit2.LoadFromImage(imagePath)

	if count != 2 {
		t.Errorf("Expected 2 methods after update, got %d", count)
	}
}

func TestLoadFromImageNoAOTSection(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()

	// Create image without AOT section
	tmpDir := t.TempDir()
	imagePath := filepath.Join(tmpDir, "noaot.image")
	fakeImage := make([]byte, ImageHeaderSize+50)
	copy(fakeImage[:4], []byte("MAGI"))
	os.WriteFile(imagePath, fakeImage, 0644)

	// Should return 0, no error
	count, err := jit.LoadFromImage(imagePath)
	if err != nil {
		t.Errorf("LoadFromImage should not error for missing AOT: %v", err)
	}
	if count != 0 {
		t.Errorf("Expected 0 methods, got %d", count)
	}
}

func TestFindAOTSection(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()

	// Image without AOT
	noAOT := make([]byte, 100)
	if jit.findAOTSection(noAOT) != -1 {
		t.Error("Should not find AOT section in empty image")
	}

	// Image with AOT at end
	withAOT := make([]byte, 100)
	copy(withAOT[80:84], aotSectionMagic[:])
	pos := jit.findAOTSection(withAOT)
	if pos != 80 {
		t.Errorf("Expected AOT at position 80, got %d", pos)
	}
}

func TestStripExistingAOT(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()

	// Create image with AOT section
	original := make([]byte, 50)
	for i := range original {
		original[i] = byte(i)
	}

	// Add fake AOT section
	withAOT := make([]byte, 70)
	copy(withAOT, original)
	copy(withAOT[50:54], aotSectionMagic[:])

	// Strip should return original
	stripped := jit.stripExistingAOT(withAOT)
	if len(stripped) != 50 {
		t.Errorf("Expected stripped length 50, got %d", len(stripped))
	}
	if !bytes.Equal(stripped, original) {
		t.Error("Stripped content should match original")
	}
}

func TestSaveAndLoadCompiledCode(t *testing.T) {
	// Test PersistenceNone
	vm := NewVM()
	jit := vm.EnableJIT()

	err := jit.SaveCompiledCode(PersistenceNone, "")
	if err != nil {
		t.Errorf("SaveCompiledCode(None) should not error: %v", err)
	}

	err = jit.LoadCompiledCode(PersistenceNone, "")
	if err != nil {
		t.Errorf("LoadCompiledCode(None) should not error: %v", err)
	}

	// Test PersistenceStatic save
	tmpDir := t.TempDir()
	class := vm.createClass("SaveTest", vm.ObjectClass)
	builder := NewCompiledMethodBuilder("test", 0)
	builder.Bytecode().Emit(OpReturnNil)
	method := builder.Build()
	method.SetClass(class)
	jit.compileMethod(method)

	err = jit.SaveCompiledCode(PersistenceStatic, tmpDir)
	if err != nil {
		t.Errorf("SaveCompiledCode(Static) failed: %v", err)
	}

	// Static mode can't load at runtime
	err = jit.LoadCompiledCode(PersistenceStatic, tmpDir)
	if err == nil {
		t.Error("LoadCompiledCode(Static) should error")
	}

	// Test PersistenceImage
	imagePath := filepath.Join(tmpDir, "save.image")
	fakeImage := make([]byte, ImageHeaderSize+50)
	copy(fakeImage[:4], []byte("MAGI"))
	os.WriteFile(imagePath, fakeImage, 0644)

	err = jit.SaveCompiledCode(PersistenceImage, imagePath)
	if err != nil {
		t.Errorf("SaveCompiledCode(Image) failed: %v", err)
	}

	vm2 := NewVM()
	jit2 := vm2.EnableJIT()
	err = jit2.LoadCompiledCode(PersistenceImage, imagePath)
	if err != nil {
		t.Errorf("LoadCompiledCode(Image) failed: %v", err)
	}
}

func TestParseAOTSectionErrors(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()

	// Too short
	_, err := jit.parseAOTSection([]byte{1, 2, 3})
	if err == nil {
		t.Error("Should error on too-short data")
	}

	// Bad magic
	badMagic := make([]byte, 24)
	copy(badMagic[:4], []byte("BAD!"))
	_, err = jit.parseAOTSection(badMagic)
	if err == nil || !strings.Contains(err.Error(), "magic") {
		t.Error("Should error on bad magic")
	}

	// Bad version
	badVersion := make([]byte, 24)
	copy(badVersion[:4], aotSectionMagic[:])
	badVersion[4] = 99 // Version 99
	_, err = jit.parseAOTSection(badVersion)
	if err == nil || !strings.Contains(err.Error(), "version") {
		t.Error("Should error on bad version")
	}
}

func TestLoadFromImageData(t *testing.T) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Compile a method
	class := vm.createClass("DataTest", vm.ObjectClass)
	builder := NewCompiledMethodBuilder("fromData", 0)
	builder.Bytecode().Emit(OpReturnNil)
	method := builder.Build()
	method.SetClass(class)
	jit.compileMethod(method)

	// Build AOT section
	section, _ := jit.buildAOTSection(false)

	// Create image data with AOT appended
	imageData := make([]byte, ImageHeaderSize+50+len(section))
	copy(imageData[:4], []byte("MAGI"))
	copy(imageData[ImageHeaderSize+50:], section)

	// Load from data
	vm2 := NewVM()
	jit2 := vm2.EnableJIT()
	count, err := jit2.LoadFromImageData(imageData)
	if err != nil {
		t.Fatalf("LoadFromImageData failed: %v", err)
	}
	if count != 1 {
		t.Errorf("Expected 1 method, got %d", count)
	}

	// Verify method loaded
	if jit2.GetCompiledMethod("DataTest", "fromData") == "" {
		t.Error("Method should be loaded")
	}
}

// BenchmarkAOTSectionBuild measures AOT section building performance.
func BenchmarkAOTSectionBuild(b *testing.B) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	// Create several methods
	class := vm.createClass("BenchClass", vm.ObjectClass)
	for i := 0; i < 20; i++ {
		builder := NewCompiledMethodBuilder(string(rune('a'+i)), 0)
		builder.Bytecode().EmitInt8(OpPushInt8, int8(i))
		builder.Bytecode().Emit(OpReturnTop)
		method := builder.Build()
		method.SetClass(class)
		jit.compileMethod(method)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		jit.buildAOTSection(false)
	}
}

// BenchmarkAOTSectionBuildCompressed measures compressed AOT section building.
func BenchmarkAOTSectionBuildCompressed(b *testing.B) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	class := vm.createClass("BenchClass", vm.ObjectClass)
	for i := 0; i < 20; i++ {
		builder := NewCompiledMethodBuilder(string(rune('a'+i)), 0)
		builder.Bytecode().EmitInt8(OpPushInt8, int8(i))
		builder.Bytecode().Emit(OpReturnTop)
		method := builder.Build()
		method.SetClass(class)
		jit.compileMethod(method)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		jit.buildAOTSection(true)
	}
}

// BenchmarkAOTSectionParse measures AOT section parsing performance.
func BenchmarkAOTSectionParse(b *testing.B) {
	vm := NewVM()
	jit := vm.EnableJIT()
	jit.LogCompilation = false

	class := vm.createClass("BenchClass", vm.ObjectClass)
	for i := 0; i < 20; i++ {
		builder := NewCompiledMethodBuilder(string(rune('a'+i)), 0)
		builder.Bytecode().EmitInt8(OpPushInt8, int8(i))
		builder.Bytecode().Emit(OpReturnTop)
		method := builder.Build()
		method.SetClass(class)
		jit.compileMethod(method)
	}

	section, _ := jit.buildAOTSection(false)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		jit.parseAOTSection(section)
	}
}
