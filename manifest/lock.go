package manifest

import (
	"fmt"
	"os"

	"github.com/BurntSushi/toml"
)

// LockFile represents the .maggie/lock.toml file.
type LockFile struct {
	Deps []LockedDep `toml:"deps"`
}

// LockedDep represents a locked dependency.
type LockedDep struct {
	Name   string `toml:"name"`
	Git    string `toml:"git,omitempty"`
	Commit string `toml:"commit,omitempty"`
	Tag    string `toml:"tag,omitempty"`
	Path   string `toml:"path,omitempty"`
}

// ReadLock reads a lock file from the given path.
// Returns nil if the file doesn't exist.
func ReadLock(path string) (*LockFile, error) {
	data, err := os.ReadFile(path)
	if os.IsNotExist(err) {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("cannot read %s: %w", path, err)
	}

	var lf LockFile
	if err := toml.Unmarshal(data, &lf); err != nil {
		return nil, fmt.Errorf("parse error in %s: %w", path, err)
	}

	return &lf, nil
}

// WriteLock writes the lock file to the given path.
func WriteLock(path string, lf *LockFile) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("cannot create %s: %w", path, err)
	}
	defer f.Close()

	fmt.Fprintln(f, "# Auto-generated by mag. DO NOT EDIT.")
	fmt.Fprintln(f)

	encoder := toml.NewEncoder(f)
	if err := encoder.Encode(lf); err != nil {
		return fmt.Errorf("cannot write %s: %w", path, err)
	}

	return nil
}

// FindLockedDep finds a locked dependency by name.
func (lf *LockFile) FindLockedDep(name string) *LockedDep {
	if lf == nil {
		return nil
	}
	for i := range lf.Deps {
		if lf.Deps[i].Name == name {
			return &lf.Deps[i]
		}
	}
	return nil
}
