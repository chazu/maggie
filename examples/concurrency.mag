# concurrency.mag
# Channels and processes (Go-style concurrency)

# Create a channel
| ch |
ch := Channel new.

# Send and receive
ch send: 42.
ch receive.                 # => 42

# Fork a process
| result |
result := [3 + 4] fork.
result wait.                # => 7

# Producer-consumer pattern
| ch producer consumer |
ch := Channel new.

producer := [
    1 to: 5 do: [:i | ch send: i].
    ch close
] fork.

consumer := [
    | sum val |
    sum := 0.
    [ch isClosed not] whileTrue: [
        val := ch receive.
        val notNil ifTrue: [sum := sum + val]
    ].
    sum
] fork.

consumer wait.              # => 15

# Try operations (non-blocking)
| ch |
ch := Channel new.
ch trySend: 42.             # => Success or Failure
ch tryReceive.              # => Success(42) or Failure

# Check channel state
ch isEmpty.
ch isClosed.

# Current process
| me |
me := Process current.
me isAlive.                 # => true

# Yielding control
Process yield.

# Sleep (milliseconds)
Process sleep: 100.

# ---------------------------------------------------------------------------
# Channel Select (Go-style select statement)
# ---------------------------------------------------------------------------

# Select waits on multiple channels, executing the handler
# for whichever channel becomes ready first

# Basic select with multiple channels
| ch1 ch2 result |
ch1 := Channel new: 1.
ch2 := Channel new: 1.

# Send to one channel
ch2 send: 'hello'.

# Select waits for any channel to be ready
result := Channel select: {
    ch1 onReceive: [:v | 'Got from ch1: ', v].
    ch2 onReceive: [:v | 'Got from ch2: ', v]
}.
# => 'Got from ch2: hello'

# Non-blocking select with default case
| ch |
ch := Channel new: 1.

result := Channel select: {
    ch onReceive: [:v | 'Received: ', v]
} ifNone: [
    'No channel ready'
].
# => 'No channel ready' (since channel is empty)

# Select with timeout pattern
| ch timeout |
ch := Channel new.
timeout := Channel new: 1.

# Start a timeout in another process
[Process sleep: 100. timeout send: 'timeout'] fork.

result := Channel select: {
    ch onReceive: [:v | 'Got value: ', v].
    timeout onReceive: [:v | 'Timed out!']
}.
# => 'Timed out!' (if ch doesn't receive within 100ms)

# Fan-in pattern: merge multiple channels
| sources merged producer1 producer2 consumer |
sources := { Channel new. Channel new. Channel new }.
merged := Channel new: 10.

# Producers send to individual channels
producer1 := [sources at: 0. send: 'from 1'] fork.
producer2 := [sources at: 1. send: 'from 2'] fork.

# Merger forwards from all sources to merged
[
    | done |
    done := false.
    [done not] whileTrue: [
        Channel select: {
            (sources at: 0) onReceive: [:v | merged send: v].
            (sources at: 1) onReceive: [:v | merged send: v].
            (sources at: 2) onReceive: [:v | merged send: v]
        } ifNone: [
            done := true
        ]
    ]
] fork.

# ---------------------------------------------------------------------------
# Mutex (mutual exclusion)
# ---------------------------------------------------------------------------

| mutex counter |
mutex := Mutex new.
counter := 0.

# Critical section
mutex lock.
counter := counter + 1.
mutex unlock.

# Safer: using critical: block
mutex critical: [
    counter := counter + 1
].

# ---------------------------------------------------------------------------
# WaitGroup (waiting for multiple processes)
# ---------------------------------------------------------------------------

| wg results |
wg := WaitGroup new.
results := Channel new: 5.

# Start multiple workers
1 to: 5 do: [:i |
    wg wrap: [
        Process sleep: (i * 10).  # Simulate work
        results send: i * i
    ]
].

# Wait for all workers to complete
wg wait.
results close.

# Collect results
results do: [:r | Transcript show: r; cr].

# ---------------------------------------------------------------------------
# Semaphore (limiting concurrent access)
# ---------------------------------------------------------------------------

| sem |
# Create semaphore with 3 permits (allow 3 concurrent accesses)
sem := Semaphore new: 3.

# Acquire a permit (blocks if none available)
sem acquire.
# ... do work ...
sem release.

# Try to acquire without blocking
sem tryAcquire ifTrue: [
    # Got a permit
    sem release
] ifFalse: [
    # No permits available
].

# Critical section with semaphore
sem critical: [
    # Only 3 processes can be here at once
    # ... exclusive work ...
].

# ---------------------------------------------------------------------------
# CancellationContext (Go-style context for cancellation and timeouts)
# ---------------------------------------------------------------------------

# Background context - never cancelled, use as base
| ctx |
ctx := CancellationContext background.
ctx isCancelled.             # => false (always)

# Cancellable context
| ctx |
ctx := CancellationContext withCancel.
ctx isCancelled.             # => false
ctx cancel.
ctx isCancelled.             # => true

# Timeout context - automatically cancelled after timeout
| ctx |
ctx := CancellationContext withTimeout: 1000.  # 1 second
ctx hasDeadline.             # => true
ctx remainingTime.           # => ~1000 (milliseconds remaining)
# ... after 1 second, ctx is automatically cancelled

# Child contexts - cancelled when parent is cancelled
| parent child |
parent := CancellationContext withCancel.
child := parent withCancel.
parent cancel.
child isCancelled.           # => true (inherited cancellation)

# Context with timeout derived from parent
| parent child |
parent := CancellationContext withCancel.
child := parent withTimeout: 500.
# child cancelled if parent cancelled OR after 500ms

# Using do: to auto-cancel when done
| ctx result |
ctx := CancellationContext withCancel.
result := ctx do: [
    # ... do work ...
    42
].
# ctx is now cancelled (cleanup happened)

# Fork a process with cancellation support
| ctx proc |
ctx := CancellationContext withTimeout: 5000.

proc := [:context |
    | i |
    i := 0.
    [context isCancelled not] whileTrue: [
        i := i + 1.
        Process sleep: 100.
        Transcript show: 'Working... '; show: i; cr
    ].
    Transcript show: 'Cancelled after '; show: i; show: ' iterations'; cr.
    i
] forkWithContext: ctx.

# Wait for process or timeout
proc wait.

# Pattern: Long-running operation with cancellation check
| ctx |
ctx := CancellationContext withTimeout: 10000.

1 to: 1000 do: [:i |
    ctx isCancelled ifTrue: [
        ^ 'Operation cancelled'  # Early exit
    ].
    # ... do work iteration ...
].

# Pattern: Using done channel with select for timeout
| ctx dataCh result |
ctx := CancellationContext withTimeout: 1000.
dataCh := Channel new.

# In another process: dataCh send: someValue

result := Channel select: {
    dataCh onReceive: [:v | v].
    ctx doneChannel onReceive: [:v | 'Timeout!']
}.

# Pattern: Graceful shutdown
| ctx workers |
ctx := CancellationContext withCancel.
workers := OrderedCollection new.

# Start workers that respect cancellation
1 to: 5 do: [:i |
    workers add: ([:context :id |
        [context isCancelled not] whileTrue: [
            # ... process work ...
            Process sleep: 100
        ].
        Transcript show: 'Worker '; show: id; show: ' stopped'; cr
    ] forkWithContext: ctx)
].

# Later: trigger graceful shutdown
ctx cancel.

# Wait for all workers to finish
workers do: [:w | w wait].
