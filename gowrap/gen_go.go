package gowrap

import (
	"fmt"
	"go/types"
	"strings"
)

// GenerateGoGlue generates the Go wrapper code for a PackageModel.
// The output is a Go source file that registers primitives with the VM.
func GenerateGoGlue(model *PackageModel) (string, error) {
	namespace := GoPackageToMaggieNamespace(model.ImportPath)

	var b strings.Builder

	// Header
	fmt.Fprintf(&b, "// Code generated by mag wrap %s. DO NOT EDIT.\n", model.ImportPath)
	fmt.Fprintf(&b, "package wrap_%s\n\n", sanitizePackageName(model.Name))
	fmt.Fprintf(&b, "import (\n")
	fmt.Fprintf(&b, "\t\"reflect\"\n")
	if hasErrorReturns(model) {
		fmt.Fprintf(&b, "\t\"fmt\"\n")
	}
	fmt.Fprintf(&b, "\n")
	fmt.Fprintf(&b, "\tpkg %q\n", model.ImportPath)
	fmt.Fprintf(&b, "\t\"github.com/chazu/maggie/vm\"\n")
	fmt.Fprintf(&b, ")\n\n")

	// Suppress unused import warnings
	fmt.Fprintf(&b, "var _ = reflect.TypeOf\n")
	if hasErrorReturns(model) {
		fmt.Fprintf(&b, "var _ = fmt.Errorf\n")
	}
	fmt.Fprintf(&b, "\n")

	// RegisterPrimitives function
	fmt.Fprintf(&b, "// RegisterPrimitives registers all wrapped Go types and functions with the VM.\n")
	fmt.Fprintf(&b, "func RegisterPrimitives(v *vm.VM) {\n")

	// Register types
	for _, tp := range model.Types {
		if !tp.IsStruct {
			continue
		}
		className := GoNameToMaggieClassName(namespace, tp.Name)
		fmt.Fprintf(&b, "\t// Type: %s\n", tp.Name)
		fmt.Fprintf(&b, "\t%sClass := v.RegisterGoType(%q, reflect.TypeOf((*pkg.%s)(nil)))\n",
			lcFirst(tp.Name), className, tp.Name)
	}

	if len(model.Types) > 0 {
		fmt.Fprintf(&b, "\n")
	}

	// Package-level namespace class for class methods (functions)
	if len(model.Functions) > 0 || len(model.Constants) > 0 {
		fmt.Fprintf(&b, "\t// Package namespace class for class-level methods\n")
		fmt.Fprintf(&b, "\tnsClass := v.RegisterGoType(%q, reflect.TypeOf((*struct{})(nil)))\n", namespace)
		fmt.Fprintf(&b, "\t_ = nsClass\n\n")
	}

	// Register package-level functions as class methods on namespace class
	for _, fn := range model.Functions {
		generateFunctionBinding(&b, fn)
	}

	// Register methods on types
	for _, tp := range model.Types {
		if !tp.IsStruct {
			continue
		}
		for _, m := range tp.Methods {
			generateMethodBinding(&b, m, tp)
		}
	}

	fmt.Fprintf(&b, "}\n")

	return b.String(), nil
}

func generateFunctionBinding(b *strings.Builder, fn FunctionModel) {
	selector := GoNameToMaggieSelector(fn.Name, len(fn.Params))
	if len(fn.Params) > 4 {
		fmt.Fprintf(b, "\t// Skipped: %s (too many parameters: %d)\n", fn.Name, len(fn.Params))
		return
	}

	fmt.Fprintf(b, "\tnsClass.AddClassMethod(v.Selectors, %q, vm.NewPrimitiveMethod(%q, func(vmPtr interface{}, receiver vm.Value, args []vm.Value) vm.Value {\n",
		selector, selector)
	fmt.Fprintf(b, "\t\tv := vmPtr.(*vm.VM)\n")

	// Extract Go args
	for i, p := range fn.Params {
		conv := goTypeConversion(p.GoType, fmt.Sprintf("args[%d]", i))
		if conv != "" {
			fmt.Fprintf(b, "\t\targ%d := %s\n", i, conv)
		}
	}

	callArgs := buildCallArgs(fn.Params)
	callExpr := fmt.Sprintf("pkg.%s(%s)", fn.Name, strings.Join(callArgs, ", "))

	writeReturnHandling(b, callExpr, fn.Results, fn.ReturnsErr)
	fmt.Fprintf(b, "\t}))\n\n")
}

func generateMethodBinding(b *strings.Builder, m FunctionModel, tp TypeModel) {
	selector := GoNameToMaggieSelector(m.Name, len(m.Params))
	if len(m.Params) > 4 {
		fmt.Fprintf(b, "\t// Skipped: %s.%s (too many parameters: %d)\n", tp.Name, m.Name, len(m.Params))
		return
	}

	varName := lcFirst(tp.Name) + "Class"
	fmt.Fprintf(b, "\t%s.AddPrimitiveMethod(v.Selectors, %q, func(vmPtr interface{}, receiver vm.Value, args []vm.Value) vm.Value {\n",
		varName, selector)
	fmt.Fprintf(b, "\t\tv := vmPtr.(*vm.VM)\n")

	// Extract Go receiver
	fmt.Fprintf(b, "\t\tgoVal, ok := v.GetGoObject(receiver)\n")
	fmt.Fprintf(b, "\t\tif !ok {\n")
	fmt.Fprintf(b, "\t\t\treturn vm.Nil\n")
	fmt.Fprintf(b, "\t\t}\n")
	fmt.Fprintf(b, "\t\tself := goVal.(*pkg.%s)\n", tp.Name)

	// Extract Go args
	for i, p := range m.Params {
		conv := goTypeConversion(p.GoType, fmt.Sprintf("args[%d]", i))
		if conv != "" {
			fmt.Fprintf(b, "\t\targ%d := %s\n", i, conv)
		}
	}

	callArgs := buildCallArgs(m.Params)
	callExpr := fmt.Sprintf("self.%s(%s)", m.Name, strings.Join(callArgs, ", "))

	writeReturnHandling(b, callExpr, m.Results, m.ReturnsErr)
	fmt.Fprintf(b, "\t})\n\n")
}

func buildCallArgs(params []ParamModel) []string {
	args := make([]string, len(params))
	for i, p := range params {
		conv := goTypeConversion(p.GoType, fmt.Sprintf("args[%d]", i))
		if conv != "" {
			args[i] = fmt.Sprintf("arg%d", i)
		} else {
			args[i] = fmt.Sprintf("v.ValueToGo(args[%d])", i)
		}
	}
	return args
}

func writeReturnHandling(b *strings.Builder, callExpr string, results []ParamModel, returnsErr bool) {
	if len(results) == 0 {
		fmt.Fprintf(b, "\t\t%s\n", callExpr)
		fmt.Fprintf(b, "\t\treturn vm.Nil\n")
	} else if returnsErr && len(results) == 2 {
		fmt.Fprintf(b, "\t\tresult, err := %s\n", callExpr)
		fmt.Fprintf(b, "\t\tif err != nil {\n")
		fmt.Fprintf(b, "\t\t\tpanic(fmt.Sprintf(\"Maggie error: GoError: %%v\", err))\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t\treturn v.GoToValue(result)\n")
	} else if returnsErr && len(results) == 1 {
		fmt.Fprintf(b, "\t\terr := %s\n", callExpr)
		fmt.Fprintf(b, "\t\tif err != nil {\n")
		fmt.Fprintf(b, "\t\t\tpanic(fmt.Sprintf(\"Maggie error: GoError: %%v\", err))\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t\treturn vm.Nil\n")
	} else if len(results) == 1 {
		fmt.Fprintf(b, "\t\tresult := %s\n", callExpr)
		fmt.Fprintf(b, "\t\treturn v.GoToValue(result)\n")
	} else {
		// Multiple non-error results
		resultVars := make([]string, len(results))
		for i := range results {
			resultVars[i] = fmt.Sprintf("r%d", i)
		}
		fmt.Fprintf(b, "\t\t%s := %s\n", strings.Join(resultVars, ", "), callExpr)
		fmt.Fprintf(b, "\t\tarr := make([]vm.Value, %d)\n", len(results))
		for i := range results {
			fmt.Fprintf(b, "\t\tarr[%d] = v.GoToValue(r%d)\n", i, i)
		}
		fmt.Fprintf(b, "\t\treturn v.NewArrayWithElements(arr)\n")
	}
}

// goTypeConversion returns a Go expression that converts a Maggie Value to the
// expected Go type. Returns "" if no direct conversion is available.
func goTypeConversion(t types.Type, valueExpr string) string {
	underlying := t.Underlying()
	switch u := underlying.(type) {
	case *types.Basic:
		switch {
		case u.Info()&types.IsString != 0:
			return fmt.Sprintf("v.ValueToGo(%s).(string)", valueExpr)
		case u.Info()&types.IsBoolean != 0:
			return fmt.Sprintf("v.ValueToGo(%s).(bool)", valueExpr)
		case u.Info()&types.IsInteger != 0:
			return fmt.Sprintf("%s(%s.SmallInt())", u.Name(), valueExpr)
		case u.Info()&types.IsFloat != 0:
			return fmt.Sprintf("%s(%s.Float64())", u.Name(), valueExpr)
		}
	case *types.Slice:
		if basic, ok := u.Elem().(*types.Basic); ok && basic.Kind() == types.Byte {
			return fmt.Sprintf("[]byte(v.ValueToGo(%s).(string))", valueExpr)
		}
	case *types.Interface:
		return fmt.Sprintf("v.ValueToGo(%s)", valueExpr)
	}
	return ""
}

func hasErrorReturns(model *PackageModel) bool {
	for _, fn := range model.Functions {
		if fn.ReturnsErr {
			return true
		}
	}
	for _, tp := range model.Types {
		for _, m := range tp.Methods {
			if m.ReturnsErr {
				return true
			}
		}
	}
	return false
}

func sanitizePackageName(name string) string {
	return strings.ReplaceAll(name, "-", "_")
}

func lcFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}
