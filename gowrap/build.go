package gowrap

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// WrapperPackageInfo describes a wrapper package to include in the build.
type WrapperPackageInfo struct {
	ImportPath string // original Go import path (e.g., "strings")
	PkgName    string // short package name (e.g., "strings")
}

// BuildOptions configures the custom binary build.
type BuildOptions struct {
	OutputBinary string
	WrapDir      string
	WrapperPkgs  []WrapperPackageInfo
	ProjectDir   string
	Verbose      bool
}

// Build creates a custom Maggie binary with wrapped Go packages baked in.
// It generates a temporary Go module, writes a main.go that imports the VM
// plus all wrapper packages, and runs `go build`.
func Build(opts BuildOptions) error {
	// Create temp dir for the build
	tmpDir, err := os.MkdirTemp("", "mag-build-*")
	if err != nil {
		return fmt.Errorf("creating temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	// Resolve project module path from go.mod
	projectModule, err := detectModulePath(opts.ProjectDir)
	if err != nil {
		return fmt.Errorf("detecting module path: %w", err)
	}

	// Generate go.mod
	goModContent := generateGoMod(projectModule, opts.ProjectDir, opts.WrapDir)
	if err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goModContent), 0o644); err != nil {
		return fmt.Errorf("writing go.mod: %w", err)
	}

	// Generate main.go
	mainContent := generateMain(projectModule, opts.WrapDir, opts.WrapperPkgs)
	if err := os.WriteFile(filepath.Join(tmpDir, "main.go"), []byte(mainContent), 0o644); err != nil {
		return fmt.Errorf("writing main.go: %w", err)
	}

	if opts.Verbose {
		fmt.Printf("Build temp dir: %s\n", tmpDir)
	}

	// Resolve output path
	outputPath := opts.OutputBinary
	if !filepath.IsAbs(outputPath) {
		cwd, _ := os.Getwd()
		outputPath = filepath.Join(cwd, outputPath)
	}

	// Run go build
	cmd := exec.Command("go", "build", "-o", outputPath, ".")
	cmd.Dir = tmpDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("go build: %w", err)
	}

	return nil
}

func detectModulePath(projectDir string) (string, error) {
	goModPath := filepath.Join(projectDir, "go.mod")
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return "", fmt.Errorf("reading go.mod: %w", err)
	}
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}
	return "", fmt.Errorf("no module directive found in %s", goModPath)
}

func generateGoMod(projectModule, projectDir, wrapDir string) string {
	var b strings.Builder
	fmt.Fprintf(&b, "module mag-custom-build\n\n")
	fmt.Fprintf(&b, "go 1.24\n\n")
	fmt.Fprintf(&b, "require (\n")
	fmt.Fprintf(&b, "\t%s v0.0.0\n", projectModule)
	fmt.Fprintf(&b, ")\n\n")
	fmt.Fprintf(&b, "replace (\n")
	fmt.Fprintf(&b, "\t%s => %s\n", projectModule, projectDir)

	// Add replace for wrapper packages
	absWrapDir, _ := filepath.Abs(wrapDir)
	entries, _ := os.ReadDir(absWrapDir)
	for _, entry := range entries {
		if entry.IsDir() {
			pkgPath := fmt.Sprintf("mag-custom-build/wrap/%s", entry.Name())
			fmt.Fprintf(&b, "\t%s => %s\n", pkgPath, filepath.Join(absWrapDir, entry.Name()))
		}
	}

	fmt.Fprintf(&b, ")\n")
	return b.String()
}

func generateMain(projectModule, wrapDir string, wrapperPkgs []WrapperPackageInfo) string {
	var b strings.Builder

	fmt.Fprintf(&b, "// Code generated by mag build. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "package main\n\n")
	fmt.Fprintf(&b, "import (\n")
	fmt.Fprintf(&b, "\t\"fmt\"\n")
	fmt.Fprintf(&b, "\t\"os\"\n\n")
	fmt.Fprintf(&b, "\t\"%s/vm\"\n", projectModule)

	// Import wrapper packages
	for _, pkg := range wrapperPkgs {
		alias := "wrap_" + sanitizePackageName(pkg.PkgName)
		fmt.Fprintf(&b, "\t%s \"mag-custom-build/wrap/%s\"\n", alias, sanitizePackageName(pkg.PkgName))
	}

	fmt.Fprintf(&b, ")\n\n")

	fmt.Fprintf(&b, "func main() {\n")
	fmt.Fprintf(&b, "\tv := vm.NewVM()\n")
	fmt.Fprintf(&b, "\tdefer v.Shutdown()\n\n")

	// Register all wrapper packages
	for _, pkg := range wrapperPkgs {
		alias := "wrap_" + sanitizePackageName(pkg.PkgName)
		fmt.Fprintf(&b, "\t%s.RegisterPrimitives(v)\n", alias)
	}

	fmt.Fprintf(&b, "\n")
	fmt.Fprintf(&b, "\t// Load and run from command-line args\n")
	fmt.Fprintf(&b, "\tif len(os.Args) < 2 {\n")
	fmt.Fprintf(&b, "\t\tfmt.Fprintln(os.Stderr, \"Usage: <binary> <source-path> [-m entry]\")\n")
	fmt.Fprintf(&b, "\t\tos.Exit(1)\n")
	fmt.Fprintf(&b, "\t}\n")
	fmt.Fprintf(&b, "\t_ = fmt.Sprintf // suppress unused\n")
	fmt.Fprintf(&b, "\t_ = v\n")
	fmt.Fprintf(&b, "}\n")

	return b.String()
}
