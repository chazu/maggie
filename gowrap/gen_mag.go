package gowrap

import (
	"fmt"
	"strings"
)

// GenerateMaggieStubs generates Maggie class definitions for a PackageModel.
// The output is a .mag source file with class stubs.
func GenerateMaggieStubs(model *PackageModel) (string, error) {
	namespace := GoPackageToMaggieNamespace(model.ImportPath)
	// e.g., "Go::Strings" → parent namespace "Go", class name "Strings"
	parts := strings.SplitN(namespace, "::", 2)
	parentNS := parts[0]
	pkgClass := parts[1] // e.g., "Strings", "Json"

	var b strings.Builder

	fmt.Fprintf(&b, "\" Code generated by mag wrap %s. DO NOT EDIT.\n", model.ImportPath)
	fmt.Fprintf(&b, "namespace: '%s'\n\n", parentNS)

	// Package namespace class with class methods (functions)
	if len(model.Functions) > 0 || len(model.Constants) > 0 {
		fmt.Fprintf(&b, "%s subclass: Object\n", pkgClass)

		for _, fn := range model.Functions {
			selector := GoNameToMaggieSelector(fn.Name, len(fn.Params))
			if len(fn.Params) > 4 {
				continue
			}
			fmt.Fprintf(&b, "  classMethod: %s [ <primitive> ]\n", formatSelector(selector, fn.Params))
		}

		fmt.Fprintf(&b, "\n")
	}

	// Types as classes
	for _, tp := range model.Types {
		if !tp.IsStruct {
			continue
		}
		fmt.Fprintf(&b, "%s subclass: Object\n", tp.Name)

		for _, m := range tp.Methods {
			if len(m.Params) > 4 {
				continue
			}
			selector := GoNameToMaggieSelector(m.Name, len(m.Params))
			fmt.Fprintf(&b, "  method: %s [ <primitive> ]\n", formatSelector(selector, m.Params))
		}

		fmt.Fprintf(&b, "\n")
	}

	return b.String(), nil
}

// formatSelector creates the method signature for the Maggie stub.
// e.g., selector "contains:substr:" with 2 params → "contains: s substr: t"
func formatSelector(selector string, params []ParamModel) string {
	if len(params) == 0 {
		return selector
	}

	parts := strings.Split(selector, ":")
	// Remove trailing empty string from split
	for len(parts) > 0 && parts[len(parts)-1] == "" {
		parts = parts[:len(parts)-1]
	}

	var b strings.Builder
	for i, part := range parts {
		if i > 0 {
			b.WriteString(" ")
		}
		b.WriteString(part)
		b.WriteString(": ")
		if i < len(params) {
			b.WriteString(paramVarName(params[i], i))
		} else {
			fmt.Fprintf(&b, "p%d", i)
		}
	}
	return b.String()
}

func paramVarName(p ParamModel, idx int) string {
	if p.Name != "" && p.Name != "_" {
		return lcFirst(p.Name)
	}
	return fmt.Sprintf("p%d", idx)
}
