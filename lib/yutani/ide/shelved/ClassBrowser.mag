# ClassBrowser.mag
# A three-pane class browser for Maggie IDE.
# Shows categories, classes, and methods with source code view.

ClassBrowser subclass: Object
  instanceVars: session mainFlex topPane categoryList classList methodList codeView selectedClass

  # Creation
  classMethod: openIn: aSession [
      ^self new initializeIn: aSession; open
  ]

  method: initializeIn: aSession [
      session := aSession.
      self buildUI.
      self populateCategories.
      ^self
  ]

  method: buildUI [
      # Main vertical flex layout
      mainFlex := session createFlex.
      mainFlex direction: #column.
      mainFlex title: 'Class Browser'.
      mainFlex border: true.

      # Top pane with three lists (horizontal)
      topPane := session createFlex.
      topPane direction: #row.

      # Category list
      categoryList := session createList.
      categoryList title: 'Categories'.
      categoryList border: true.
      categoryList onSelected: [:e | self categorySelected: e].

      # Class list
      classList := session createList.
      classList title: 'Classes'.
      classList border: true.
      classList onSelected: [:e | self classSelected: e].

      # Method list
      methodList := session createList.
      methodList title: 'Methods'.
      methodList border: true.
      methodList onSelected: [:e | self methodSelected: e].

      # Add lists to top pane with equal proportions
      topPane addItem: categoryList proportion: 1.
      topPane addItem: classList proportion: 1.
      topPane addItem: methodList proportion: 1.

      # Code view at bottom
      codeView := session createTextArea.
      codeView title: 'Source'.
      codeView border: true.
      codeView wordWrap: true.

      # Add panes to main layout
      mainFlex addItem: topPane proportion: 1.
      mainFlex addItem: codeView proportion: 2.

      # Set up key bindings
      self setupKeyBindings
  ]

  method: setupKeyBindings [
      session onKey: [:event |
          event isCtrl ifTrue: [
              event rune = 'q' ifTrue: [self close].
              event rune = 'r' ifTrue: [self refresh]
          ]
      ]
  ]

  method: open [
      session setRoot: mainFlex.
      categoryList focus.
      session run  "Block until event loop terminates"
  ]

  method: close [
      session stopEventLoop.
      session disconnect
  ]

  # Data population
  method: populateCategories [
      | categories |
      categories := self systemCategories.
      categories do: [:cat | categoryList addItem: cat]
  ]

  method: categorySelected: event [
      | category classes |
      category := event dataAt: #main_text.
      category ifNil: [^self].

      classList clear.
      methodList clear.
      codeView text: ''.

      classes := self classesInCategory: category.
      classes do: [:cls | classList addItem: cls]
  ]

  method: classSelected: event [
      | className |
      className := event dataAt: #main_text.
      className ifNil: [^self].

      selectedClass := self classNamed: className.
      methodList clear.
      codeView text: ''.

      selectedClass notNil ifTrue: [
          self methodsForClass: selectedClass do: [:sel |
              methodList addItem: sel
          ]
      ]
  ]

  method: methodSelected: event [
      | selector source |
      selector := event dataAt: #main_text.
      selector ifNil: [^self].
      selectedClass ifNil: [^self].

      source := self sourceFor: selector in: selectedClass.
      codeView text: (source ifNil: ['# Source not available'])
  ]

  method: refresh [
      categoryList clear.
      classList clear.
      methodList clear.
      codeView text: ''.
      selectedClass := nil.
      self populateCategories
  ]

  # System introspection using real reflection APIs

  method: systemCategories [
      "Return list of class categories based on naming conventions."
      ^#('All' 'Kernel' 'Collections' 'Numbers' 'Compiler' 'Yutani' 'IDE' 'Exceptions' 'Other')
  ]

  method: classesInCategory: category [
      "Return class names matching the category."
      | allClasses |
      allClasses := Object allClassesSorted.

      category = 'All' ifTrue: [^allClasses].

      category = 'Kernel' ifTrue: [
          ^allClasses select: [:c |
              #(#Object #Boolean #True #False #UndefinedObject #Block
                #Process #Channel #Result #Success #Failure #Context
                #Class #WeakReference) includes: c]
      ].
      category = 'Collections' ifTrue: [
          ^allClasses select: [:c |
              #(#Array #Dictionary #String #Symbol #ByteArray #Association) includes: c]
      ].
      category = 'Numbers' ifTrue: [
          ^allClasses select: [:c |
              #(#SmallInteger #Float) includes: c]
      ].
      category = 'Compiler' ifTrue: [
          ^allClasses select: [:c |
              (c asString beginsWith: 'Compiler') or: [
              (c asString beginsWith: 'Lexer') or: [
              (c asString beginsWith: 'Parser') or: [
              (c asString beginsWith: 'Bytecode') or: [
              (c asString beginsWith: 'Token') or: [
              #(#CharacterStream #LiteralNode #VariableNode #AssignmentNode
                #MessageSendNode #BlockNode #CascadeNode #MethodNode
                #ReturnNode #ClassNode) includes: c]]]]]]
      ].
      category = 'Yutani' ifTrue: [
          ^allClasses select: [:c | c asString beginsWith: 'Yutani']
      ].
      category = 'IDE' ifTrue: [
          ^allClasses select: [:c |
              #(#ClassBrowser #MaggieREPL #CodeEditor #Inspector) includes: c]
      ].
      category = 'Exceptions' ifTrue: [
          ^allClasses select: [:c |
              #(#Exception #Error #MessageNotUnderstood #ZeroDivide
                #SubscriptOutOfBounds #Warning #Halt #Notification) includes: c]
      ].
      category = 'Other' ifTrue: [
          | known |
          known := #(#Object #Boolean #True #False #UndefinedObject #Block
                     #Process #Channel #Result #Success #Failure #Context
                     #Class #WeakReference #Array #Dictionary #String #Symbol
                     #ByteArray #Association #SmallInteger #Float
                     #Exception #Error #MessageNotUnderstood #ZeroDivide
                     #SubscriptOutOfBounds #Warning #Halt #Notification).
          ^allClasses reject: [:c |
              (known includes: c) or: [
              (c asString beginsWith: 'Yutani') or: [
              (c asString beginsWith: 'Compiler') or: [
              (c asString beginsWith: 'Lexer') or: [
              (c asString beginsWith: 'Parser') or: [
              (c asString beginsWith: 'Bytecode') or: [
              (c asString beginsWith: 'Token') or: [
              #(#CharacterStream #LiteralNode #VariableNode #AssignmentNode
                #MessageSendNode #BlockNode #CascadeNode #MethodNode
                #ReturnNode #ClassNode #ClassBrowser #MaggieREPL
                #CodeEditor #Inspector) includes: c]]]]]]]]
      ].
      ^#()
  ]

  method: classNamed: className [
      "Return the class symbol for use with reflection methods."
      ^className asSymbol
  ]

  method: methodsForClass: aClass do: block [
      "Iterate over method names of a class."
      | methods |
      methods := aClass allMethodNames.
      methods ifNotNil: [methods do: block]
  ]

  method: sourceFor: selector in: aClass [
      "Get source code for a method using reflection."
      | source |
      source := aClass methodSourceFor: selector asSymbol.
      source ifNil: [
          "Try without asSymbol in case it's already a symbol"
          source := aClass methodSourceFor: selector
      ].
      ^source
  ]

  # Printing
  method: printString [
      ^'ClassBrowser'
  ]
