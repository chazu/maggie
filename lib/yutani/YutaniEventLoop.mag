# YutaniEventLoop.mag
# Handles event streaming from Yutani server and dispatches events to handlers.

YutaniEventLoop subclass: Object
  instanceVars: session stream handlers running process doneChannel

  # Creation
  classMethod: for: aSession [
      ^self new initializeFor: aSession
  ]

  method: initializeFor: aSession [
      session := aSession.
      handlers := Dictionary new.
      running := false.
      doneChannel := Channel new.
      ^self
  ]

  # Event loop control
  method: start [
      | request client result |
      'EventLoop: start called' println.
      running := true.

      session ifNil: [
          'EventLoop: session is nil!' println.
          running := false.
          doneChannel send: true.
          ^self
      ].
      client := session client.
      client ifNil: [
          'EventLoop: client is nil!' println.
          running := false.
          doneChannel send: true.
          ^self
      ].
      session sessionId ifNil: [
          'EventLoop: sessionId is nil!' println.
          running := false.
          doneChannel send: true.
          ^self
      ].
      ('EventLoop: subscribing with sessionId: ', session sessionId printString) println.

      request := Dictionary new
          at: #session_id put: (Dictionary new at: #id put: session sessionId; yourself);
          at: #filter put: (Dictionary new
              at: #receive_key_events put: true;
              at: #receive_mouse_events put: true;
              at: #receive_resize_events put: true;
              at: #receive_focus_events put: true;
              at: #receive_widget_events put: true;
              yourself);
          yourself.

      result := client serverStream: 'industries.loosh.yutani.v1.EventService/Subscribe' with: request.
      result isSuccess ifTrue: [
          'EventLoop: Subscribe succeeded, starting event loop' println.
          stream := result value.
          ('EventLoop: stream = ', stream printString) println.
          process := [self eventLoop] fork.
          ('EventLoop: forked process = ', process printString) println
      ].
      result isFailure ifTrue: [
          ('EventLoop: Subscribe FAILED: ', result error printString) println.
          running := false.
          doneChannel send: true
      ]
  ]

  method: stop [
      running := false.
      stream notNil ifTrue: [stream close].
      process notNil ifTrue: [process terminate]
  ]

  method: isRunning [
      ^running
  ]

  # Main event loop
  method: eventLoop [
      | recvResult |
      'EventLoop: eventLoop started in forked process' println.
      ('EventLoop: stream in forked process = ', stream printString) println.
      stream ifNil: [
          'EventLoop: stream is nil in forked process!' println.
          running := false.
          doneChannel send: true.
          ^self
      ].
      'EventLoop: entering receive loop' println.
      ('EventLoop: running = ', running printString, ', hasNext = ', stream hasNext printString) println.
      [running and: [stream hasNext]] whileTrue: [
          'EventLoop: waiting for event...' println.
          recvResult := stream receive.
          ('EventLoop: receive returned, isSuccess = ', recvResult isSuccess printString) println.
          recvResult isSuccess ifTrue: [
              ('EventLoop: received event: ', recvResult value printString) println.
              self dispatchEvent: recvResult value
          ].
          recvResult isFailure ifTrue: [
              ('EventLoop: receive failed: ', recvResult error printString) println.
              recvResult error = 'end of stream'
                  ifTrue: [running := false]
                  ifFalse: [self handleError: recvResult error]
          ]
      ].
      ('EventLoop: exiting receive loop, running = ', running printString, ', hasNext = ', stream hasNext printString) println.
      running := false.
      doneChannel send: true
  ]

  # Block until the event loop terminates
  method: wait [
      doneChannel receive
  ]

  # Start event loop and block until done (convenience method)
  method: run [
      self start.
      self wait
  ]

  method: handleError: err [
      # Log error but continue running
      ('EventLoop error: ', err printString) println
  ]

  # Event dispatch
  method: dispatchEvent: eventDict [
      | event widgetId widget categoryHandlers |
      event := YutaniEvent fromDictionary: eventDict.

      # Dispatch to widget-specific handler if widget event
      widgetId := event widgetId.
      widgetId notNil ifTrue: [
          widget := session widgetAt: widgetId.
          widget notNil ifTrue: [widget handleEvent: event]
      ].

      # Dispatch to registered global handlers
      categoryHandlers := handlers at: event eventCategory ifAbsent: [#()].
      ('EventLoop: found ', categoryHandlers size printString, ' handlers for category ', event eventCategory printString) println.
      categoryHandlers do: [:handler |
          'EventLoop: calling handler' println.
          ('EventLoop: handler class = ', handler class printString) println.
          ('EventLoop: event = ', event printString) println.
          handler value: event.
          'EventLoop: handler returned' println
      ]
  ]

  # Handler registration
  method: on: eventCategory do: block [
      | categoryHandlers |
      ('EventLoop: registering handler for category: ', eventCategory printString) println.
      categoryHandlers := handlers at: eventCategory ifAbsentPut: [Array new].
      handlers at: eventCategory put: (categoryHandlers copyWith: block).
      ('EventLoop: now have ', (handlers at: eventCategory) size printString, ' handlers for ', eventCategory printString) println
  ]

  # Convenience handler registration
  method: onKey: block [ self on: #key do: block ]
  method: onMouse: block [ self on: #mouse do: block ]
  method: onResize: block [ self on: #resize do: block ]
  method: onFocus: block [ self on: #focus do: block ]
  method: onWidget: block [ self on: #widget do: block ]

  # Printing
  method: printString [
      ^'YutaniEventLoop(', (running ifTrue: ['running'] ifFalse: ['stopped']), ')'
  ]

