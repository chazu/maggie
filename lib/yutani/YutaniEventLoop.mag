# YutaniEventLoop.mag
# Handles event streaming from Yutani server and dispatches events to handlers.

YutaniEventLoop subclass: Object
  instanceVars: session stream handlers running process doneChannel

  # Creation
  classMethod: for: aSession [
      ^self new initializeFor: aSession
  ]

  method: initializeFor: aSession [
      session := aSession.
      handlers := Dictionary new.
      running := false.
      doneChannel := Channel new.
      ^self
  ]

  # Event loop control
  method: start [
      | request client result |
      running := true.

      session ifNil: [
          running := false.
          doneChannel send: true.
          ^self
      ].
      client := session client.
      client ifNil: [
          running := false.
          doneChannel send: true.
          ^self
      ].
      session sessionId ifNil: [
          running := false.
          doneChannel send: true.
          ^self
      ].

      request := Dictionary new
          at: #session_id put: (Dictionary new at: #id put: session sessionId; yourself);
          at: #filter put: (Dictionary new
              at: #receive_key_events put: true;
              at: #receive_mouse_events put: true;
              at: #receive_resize_events put: true;
              at: #receive_focus_events put: true;
              at: #receive_widget_events put: true;
              yourself);
          yourself.

      result := client serverStream: 'industries.loosh.yutani.v1.EventService/Subscribe' with: request.
      result isSuccess ifTrue: [
          stream := result value.
          process := [self eventLoop] fork
      ].
      result isFailure ifTrue: [
          ('EventLoop: Subscribe FAILED: ', result error printString) println.
          running := false.
          doneChannel send: true
      ]
  ]

  method: stop [
      running := false.
      stream notNil ifTrue: [stream close].
      process notNil ifTrue: [process terminate]
  ]

  method: isRunning [
      ^running
  ]

  # Main event loop
  method: eventLoop [
      | recvResult |
      stream ifNil: [
          running := false.
          doneChannel send: true.
          ^self
      ].
      [running and: [stream hasNext]] whileTrue: [
          recvResult := stream receive.
          recvResult isSuccess ifTrue: [
              self dispatchEvent: recvResult value
          ].
          recvResult isFailure ifTrue: [
              recvResult error = 'end of stream'
                  ifTrue: [running := false]
                  ifFalse: [self handleError: recvResult error]
          ]
      ].
      running := false.
      doneChannel send: true
  ]

  # Block until the event loop terminates
  method: wait [
      doneChannel receive
  ]

  # Start event loop and block until done (convenience method)
  method: run [
      self start.
      self wait
  ]

  method: handleError: err [
      # Log error but continue running
      ('EventLoop error: ', err printString) println
  ]

  # Event dispatch
  method: dispatchEvent: eventDict [
      | event widgetId widget categoryHandlers |
      event := YutaniEvent fromDictionary: eventDict.

      # Dispatch to widget-specific handler if widget event
      widgetId := event widgetId.
      widgetId notNil ifTrue: [
          widget := session widgetAt: widgetId.
          widget notNil ifTrue: [widget handleEvent: event]
      ].

      # Dispatch to registered global handlers
      categoryHandlers := handlers at: event eventCategory ifAbsent: [#()].
      categoryHandlers do: [:handler |
          handler value: event
      ]
  ]

  # Handler registration
  method: on: eventCategory do: block [
      | categoryHandlers |
      categoryHandlers := handlers at: eventCategory ifAbsentPut: [Array new].
      handlers at: eventCategory put: (categoryHandlers copyWith: block)
  ]

  # Convenience handler registration
  method: onKey: block [ self on: #key do: block ]
  method: onMouse: block [ self on: #mouse do: block ]
  method: onResize: block [ self on: #resize do: block ]
  method: onFocus: block [ self on: #focus do: block ]
  method: onWidget: block [ self on: #widget do: block ]

  # Printing
  method: printString [
      ^'YutaniEventLoop(', (running ifTrue: ['running'] ifFalse: ['stopped']), ')'
  ]
