# Array.mag

Array subclass: Object
  include: Printable

  # Accessing
  method: size [
      ^self primSize
  ]

  method: at: index [
      "Return element at 0-based index."
      ^self primAt: index
  ]

  method: at: index put: value [
      "Set element at 0-based index."
      ^self primAt: index put: value
  ]

  method: first [
      ^self at: 0
  ]

  method: last [
      ^self at: self size - 1
  ]

  method: isEmpty [
      ^self size = 0
  ]

  method: notEmpty [
      ^self isEmpty not
  ]

  # Iteration
  method: do: block [
      0 to: self size - 1 do: [:i | block value: (self at: i)]
  ]

  method: collect: block [
      | result |
      result := Array new: self size.
      0 to: self size - 1 do: [:i | result at: i put: (block value: (self at: i))].
      ^result
  ]

  method: select: block [
      | result |
      result := Array new: 0.
      self do: [:each | (block value: each) ifTrue: [result := result, (Array with: each)]].
      ^result
  ]

  method: reject: block [
      ^self select: [:each | (block value: each) not]
  ]

  method: detect: block [
      self do: [:each | (block value: each) ifTrue: [^each]].
      ^nil
  ]

  method: detect: block ifNone: noneBlock [
      self do: [:each | (block value: each) ifTrue: [^each]].
      ^noneBlock value
  ]

  # Aggregation
  method: inject: initial into: block [
      | result |
      result := initial.
      self do: [:each | result := block value: result value: each].
      ^result
  ]

  # Testing
  method: includes: anObject [
      self do: [:each | each = anObject ifTrue: [^true]].
      ^false
  ]

  method: indexOf: anObject [
      "Return the 0-based index of anObject, or -1 if not found."
      0 to: self size - 1 do: [:i | (self at: i) = anObject ifTrue: [^i]].
      ^-1
  ]

  # Concatenation
  method: , other [
      | result |
      result := Array new: self size + other size.
      0 to: self size - 1 do: [:i | result at: i put: (self at: i)].
      0 to: other size - 1 do: [:i | result at: self size + i put: (other at: i)].
      ^result
  ]

  # Copying
  method: copyFrom: start to: end [
      "Return elements from start (inclusive) to end (exclusive), 0-based."
      | result |
      result := Array new: end - start.
      start to: end - 1 do: [:i | result at: i - start put: (self at: i)].
      ^result
  ]

  method: copyWith: element [
      "Return a new array with element appended."
      ^self, (Array with: element)
  ]

  # Printing
  method: printString [
      | s |
      s := '#('.
      self do: [:each | s := s, each printString, ' '].
      s := s, ')'.
      ^s
  ]
