# BytecodeGenerator.mag
# Compiles AST nodes to bytecode.

BytecodeGenerator subclass: Object
  instanceVars: bytecode literals selectors temps ivars captures currentClass blockMethods jumpPatches outerTemps inBlock cellVars cellInitialized capturedVars blockNestingDepth enclosingBlockVars blockArity blockNumTemps

  # Opcodes (matching vm/opcodes.go)
  classMethod: opNOP [^16r00]
  classMethod: opPOP [^16r01]
  classMethod: opDUP [^16r02]

  classMethod: opPUSH_NIL [^16r10]
  classMethod: opPUSH_TRUE [^16r11]
  classMethod: opPUSH_FALSE [^16r12]
  classMethod: opPUSH_SELF [^16r13]
  classMethod: opPUSH_INT8 [^16r14]
  classMethod: opPUSH_INT32 [^16r15]
  classMethod: opPUSH_LITERAL [^16r16]
  classMethod: opPUSH_FLOAT [^16r17]

  classMethod: opPUSH_TEMP [^16r20]
  classMethod: opPUSH_IVAR [^16r21]
  classMethod: opPUSH_GLOBAL [^16r22]
  classMethod: opSTORE_TEMP [^16r23]
  classMethod: opSTORE_IVAR [^16r24]
  classMethod: opSTORE_GLOBAL [^16r25]
  classMethod: opPUSH_CAPTURED [^16r26]
  classMethod: opSTORE_CAPTURED [^16r27]
  classMethod: opPUSH_HOME_TEMP [^16r28]
  classMethod: opSTORE_HOME_TEMP [^16r29]
  classMethod: opMAKE_CELL [^16r2A]
  classMethod: opCELL_GET [^16r2B]
  classMethod: opCELL_SET [^16r2C]

  classMethod: opSEND [^16r30]
  classMethod: opSEND_SUPER [^16r31]

  classMethod: opSEND_PLUS [^16r40]
  classMethod: opSEND_MINUS [^16r41]
  classMethod: opSEND_TIMES [^16r42]
  classMethod: opSEND_DIV [^16r43]
  classMethod: opSEND_MOD [^16r44]
  classMethod: opSEND_LT [^16r45]
  classMethod: opSEND_GT [^16r46]
  classMethod: opSEND_LE [^16r47]
  classMethod: opSEND_GE [^16r48]
  classMethod: opSEND_EQ [^16r49]
  classMethod: opSEND_NE [^16r4A]
  classMethod: opSEND_AT [^16r4B]
  classMethod: opSEND_AT_PUT [^16r4C]
  classMethod: opSEND_SIZE [^16r4D]
  classMethod: opSEND_VALUE [^16r4E]
  classMethod: opSEND_VALUE1 [^16r4F]
  classMethod: opSEND_VALUE2 [^16r50]
  classMethod: opSEND_NEW [^16r51]
  classMethod: opSEND_CLASS [^16r52]

  classMethod: opJUMP [^16r60]
  classMethod: opJUMP_TRUE [^16r61]
  classMethod: opJUMP_FALSE [^16r62]
  classMethod: opJUMP_NIL [^16r63]
  classMethod: opJUMP_NOT_NIL [^16r64]

  classMethod: opRETURN_TOP [^16r70]
  classMethod: opRETURN_SELF [^16r71]
  classMethod: opRETURN_NIL [^16r72]
  classMethod: opBLOCK_RETURN [^16r73]

  classMethod: opCREATE_BLOCK [^16r80]
  classMethod: opCAPTURE_TEMP [^16r81]
  classMethod: opCAPTURE_IVAR [^16r82]

  classMethod: opCREATE_ARRAY [^16r90]
  classMethod: opCREATE_OBJECT [^16r91]

  # Creation
  classMethod: new [
      ^super new initialize
  ]

  classMethod: forClass: aClass [
      ^self new initializeForClass: aClass
  ]

  # Initialization
  method: initialize [
      bytecode := Array new.
      literals := Array new.
      selectors := Array new.
      temps := Array new.
      ivars := Array new.
      captures := Array new.
      blockMethods := Array new.
      jumpPatches := Array new.
      currentClass := nil.
      outerTemps := nil.
      inBlock := false.
      cellVars := Dictionary new.
      cellInitialized := Dictionary new.
      capturedVars := nil.
      blockNestingDepth := 0.
      enclosingBlockVars := nil.
      blockArity := 0.
      blockNumTemps := 0.
      ^self
  ]

  method: initializeForClass: aClass [
      self initialize.
      currentClass := aClass.
      ivars := aClass instanceVariables.
      ^self
  ]

  # Accessing
  method: bytecode [^bytecode]
  method: literals [^literals]
  method: selectors [^selectors]
  method: blockMethods [^blockMethods]
  method: temps [^temps]
  method: captures [^captures]
  method: capturedVars [^capturedVars]
  method: cellVars [^cellVars]
  method: blockArity [^blockArity]
  method: blockNumTemps [^blockNumTemps]

  # ============================================
  # Literal table management
  # ============================================

  method: addLiteral: value [
      "Add a literal to the table, return its index. Reuse if duplicate."
      | index |
      index := literals indexOf: value.
      index >= 0 ifTrue: [^index].  "Already exists"
      literals := literals copyWith: value.
      ^literals size - 1
  ]

  method: addSelector: selector [
      "Add a selector, return its index."
      | index |
      index := selectors indexOf: selector.
      index >= 0 ifTrue: [^index].
      selectors := selectors copyWith: selector.
      ^selectors size - 1
  ]

  # ============================================
  # Variable management
  # ============================================

  method: addTemp: name [
      "Add a temporary variable, return its index."
      temps := temps copyWith: name.
      ^temps size - 1
  ]

  method: tempIndex: name [
      "Get index of a temp variable, or -1 if not found."
      ^temps indexOf: name
  ]

  method: ivarIndex: name [
      "Get index of an instance variable, or -1 if not found."
      ^ivars indexOf: name
  ]

  method: captureIndex: name [
      "Get or create capture index for a variable."
      | index |
      index := captures indexOf: name.
      index >= 0 ifTrue: [^index].
      captures := captures copyWith: name.
      ^captures size - 1
  ]

  method: setOuterTemps: aDictionary [
      "Set the outer scope temps for block compilation."
      outerTemps := aDictionary.
      inBlock := true
  ]

  method: outerTempIndex: name [
      "Get index of an outer scope temp, or -1 if not found."
      outerTemps isNil ifTrue: [^-1].
      ^outerTemps at: name ifAbsent: [-1]
  ]

  method: isInBlock [
      ^inBlock
  ]

  method: setCellVars: aDict [
      "Set cell variables dictionary (shared across method compilation)."
      cellVars := aDict
  ]

  method: isCellVar: name [
      "Check if a variable needs cell boxing."
      ^cellVars includesKey: name
  ]

  method: isCellInitialized: name [
      "Check if a cell has been initialized for a variable."
      ^cellInitialized includesKey: name
  ]

  method: markCellInitialized: name [
      "Mark a cell variable as initialized."
      cellInitialized at: name put: true
  ]

  method: setCapturedVars: aDict [
      "Set the captured variable map for this scope."
      capturedVars := aDict
  ]

  method: setBlockNestingDepth: depth [
      blockNestingDepth := depth
  ]

  method: setEnclosingBlockVars: aDict [
      enclosingBlockVars := aDict
  ]

  method: setBlockArity: anInt [
      blockArity := anInt
  ]

  method: setBlockNumTemps: anInt [
      blockNumTemps := anInt
  ]

  # ============================================
  # Bytecode emission helpers
  # ============================================

  method: emit: opcode [
      "Emit a single byte."
      bytecode := bytecode copyWith: opcode.
      ^self
  ]

  method: emit: opcode byte: arg [
      "Emit opcode with 8-bit argument."
      bytecode := bytecode copyWith: opcode.
      bytecode := bytecode copyWith: (arg bitAnd: 16rFF).
      ^self
  ]

  method: emit: opcode short: arg [
      "Emit opcode with 16-bit argument (little-endian, matching Go VM)."
      bytecode := bytecode copyWith: opcode.
      bytecode := bytecode copyWith: (arg bitAnd: 16rFF).
      bytecode := bytecode copyWith: ((arg bitShift: -8) bitAnd: 16rFF).
      ^self
  ]

  method: emitShort: value [
      "Emit a 16-bit value (little-endian, matching Go VM)."
      bytecode := bytecode copyWith: (value bitAnd: 16rFF).
      bytecode := bytecode copyWith: ((value bitShift: -8) bitAnd: 16rFF).
      ^self
  ]

  method: currentOffset [
      ^bytecode size
  ]

  # ============================================
  # Push instructions
  # ============================================

  method: emitPushNil [
      self emit: BytecodeGenerator opPUSH_NIL
  ]

  method: emitPushTrue [
      self emit: BytecodeGenerator opPUSH_TRUE
  ]

  method: emitPushFalse [
      self emit: BytecodeGenerator opPUSH_FALSE
  ]

  method: emitPushSelf [
      self emit: BytecodeGenerator opPUSH_SELF
  ]

  method: emitPushInteger: value [
      "Emit push for an integer value."
      (value >= -128 and: [value <= 127]) ifTrue: [
          self emit: BytecodeGenerator opPUSH_INT8 byte: value.
          ^self
      ].
      "Larger integers go in literal table"
      self emit: BytecodeGenerator opPUSH_LITERAL short: (self addLiteral: value)
  ]

  method: emitPushFloat: value [
      "Emit push for a float - store in literals."
      self emit: BytecodeGenerator opPUSH_LITERAL short: (self addLiteral: value)
  ]

  method: emitPushLiteral: value [
      "Emit push for any literal value."
      self emit: BytecodeGenerator opPUSH_LITERAL short: (self addLiteral: value)
  ]

  # ============================================
  # Variable access/store
  # ============================================

  method: emitPushTemp: index [
      self emit: BytecodeGenerator opPUSH_TEMP byte: index
  ]

  method: emitStoreTemp: index [
      self emit: BytecodeGenerator opSTORE_TEMP byte: index
  ]

  method: emitPushIvar: index [
      self emit: BytecodeGenerator opPUSH_IVAR byte: index
  ]

  method: emitStoreIvar: index [
      self emit: BytecodeGenerator opSTORE_IVAR byte: index
  ]

  method: emitPushGlobal: index [
      self emit: BytecodeGenerator opPUSH_GLOBAL short: index
  ]

  method: emitStoreGlobal: index [
      self emit: BytecodeGenerator opSTORE_GLOBAL short: index
  ]

  method: emitPushCaptured: index [
      self emit: BytecodeGenerator opPUSH_CAPTURED byte: index
  ]

  method: emitStoreCaptured: index [
      self emit: BytecodeGenerator opSTORE_CAPTURED byte: index
  ]

  method: emitPushHomeTemp: index [
      self emit: BytecodeGenerator opPUSH_HOME_TEMP byte: index
  ]

  method: emitStoreHomeTemp: index [
      self emit: BytecodeGenerator opSTORE_HOME_TEMP byte: index
  ]

  method: emitMakeCell [
      self emit: BytecodeGenerator opMAKE_CELL
  ]

  method: emitCellGet [
      self emit: BytecodeGenerator opCELL_GET
  ]

  method: emitCellSet [
      self emit: BytecodeGenerator opCELL_SET
  ]

  # ============================================
  # Message sends
  # ============================================

  method: emitSend: selector argc: argc [
      "Emit a message send. Use optimized opcodes for common selectors."
      | optimized |
      optimized := self optimizedSendFor: selector argc: argc.
      optimized notNil ifTrue: [
          self emit: optimized.
          ^self
      ].
      "General send"
      self emit: BytecodeGenerator opSEND short: (self addSelector: selector).
      self emit: argc
  ]

  method: emitSendSuper: selector argc: argc [
      self emit: BytecodeGenerator opSEND_SUPER short: (self addSelector: selector).
      self emit: argc
  ]

  method: optimizedSendFor: selector argc: argc [
      "Return optimized opcode for common selectors, or nil."
      argc = 0 ifTrue: [
          selector = #size ifTrue: [^BytecodeGenerator opSEND_SIZE].
          selector = #value ifTrue: [^BytecodeGenerator opSEND_VALUE].
          selector = #class ifTrue: [^BytecodeGenerator opSEND_CLASS].
          selector = #new ifTrue: [^BytecodeGenerator opSEND_NEW].
      ].
      argc = 1 ifTrue: [
          selector = #+ ifTrue: [^BytecodeGenerator opSEND_PLUS].
          selector = #- ifTrue: [^BytecodeGenerator opSEND_MINUS].
          selector = #* ifTrue: [^BytecodeGenerator opSEND_TIMES].
          selector = #/ ifTrue: [^BytecodeGenerator opSEND_DIV].
          selector = #\\ ifTrue: [^BytecodeGenerator opSEND_MOD].
          selector = #< ifTrue: [^BytecodeGenerator opSEND_LT].
          selector = #> ifTrue: [^BytecodeGenerator opSEND_GT].
          selector = #<= ifTrue: [^BytecodeGenerator opSEND_LE].
          selector = #>= ifTrue: [^BytecodeGenerator opSEND_GE].
          selector = #= ifTrue: [^BytecodeGenerator opSEND_EQ].
          selector = #~= ifTrue: [^BytecodeGenerator opSEND_NE].
          selector = #at: ifTrue: [^BytecodeGenerator opSEND_AT].
          selector = #value: ifTrue: [^BytecodeGenerator opSEND_VALUE1].
      ].
      argc = 2 ifTrue: [
          selector = #at:put: ifTrue: [^BytecodeGenerator opSEND_AT_PUT].
          selector = #value:value: ifTrue: [^BytecodeGenerator opSEND_VALUE2].
      ].
      ^nil
  ]

  # ============================================
  # Jump instructions
  # ============================================

  method: emitJump: offset [
      self emit: BytecodeGenerator opJUMP short: offset
  ]

  method: emitJumpTrue: offset [
      self emit: BytecodeGenerator opJUMP_TRUE short: offset
  ]

  method: emitJumpFalse: offset [
      self emit: BytecodeGenerator opJUMP_FALSE short: offset
  ]

  method: emitJumpNil: offset [
      self emit: BytecodeGenerator opJUMP_NIL short: offset
  ]

  method: emitJumpForward [
      "Emit a forward jump with placeholder offset. Return patch location."
      | patchLoc |
      self emit: BytecodeGenerator opJUMP.
      patchLoc := bytecode size.
      self emitShort: 0.  "Placeholder"
      ^patchLoc
  ]

  method: emitJumpFalseForward [
      "Emit a conditional forward jump. Return patch location."
      | patchLoc |
      self emit: BytecodeGenerator opJUMP_FALSE.
      patchLoc := bytecode size.
      self emitShort: 0.
      ^patchLoc
  ]

  method: emitJumpTrueForward [
      "Emit a conditional forward jump. Return patch location."
      | patchLoc |
      self emit: BytecodeGenerator opJUMP_TRUE.
      patchLoc := bytecode size.
      self emitShort: 0.
      ^patchLoc
  ]

  method: patchJumpAt: location [
      "Patch a forward jump to point to current location (little-endian)."
      | offset |
      offset := bytecode size - location - 2.  "Offset from after the jump operand"
      bytecode at: location put: (offset bitAnd: 16rFF).
      bytecode at: location + 1 put: ((offset bitShift: -8) bitAnd: 16rFF)
  ]

  # ============================================
  # Return instructions
  # ============================================

  method: emitReturnTop [
      self emit: BytecodeGenerator opRETURN_TOP
  ]

  method: emitReturnSelf [
      self emit: BytecodeGenerator opRETURN_SELF
  ]

  method: emitReturnNil [
      self emit: BytecodeGenerator opRETURN_NIL
  ]

  method: emitBlockReturn [
      self emit: BytecodeGenerator opBLOCK_RETURN
  ]

  # ============================================
  # Block creation
  # ============================================

  method: emitCreateBlock: blockIndex captures: captureCount [
      self emit: BytecodeGenerator opCREATE_BLOCK short: blockIndex.
      self emit: captureCount
  ]

  method: emitCaptureTemp: index [
      self emit: BytecodeGenerator opCAPTURE_TEMP byte: index
  ]

  method: emitCaptureIvar: index [
      self emit: BytecodeGenerator opCAPTURE_IVAR byte: index
  ]

  method: addBlockMethod: blockBytecodeGen [
      "Add a compiled block and return its index."
      blockMethods := blockMethods copyWith: blockBytecodeGen.
      ^blockMethods size - 1
  ]

  # ============================================
  # Stack operations
  # ============================================

  method: emitPop [
      self emit: BytecodeGenerator opPOP
  ]

  method: emitDup [
      self emit: BytecodeGenerator opDUP
  ]

  # ============================================
  # Cell variable analysis
  # ============================================

  method: findCellVariables: methodNode [
      "Analyze a method to find variables that need cell boxing.
       A variable needs a cell if it is captured by a block AND assigned in a nested block.
       Returns a Dictionary of variable name -> true.
       Uses three dictionaries to track state."
      | result varDepths capturedNames assignedNestedNames |
      result := Dictionary new.
      varDepths := Dictionary new.
      capturedNames := Dictionary new.
      assignedNestedNames := Dictionary new.

      "Register method-level parameters at depth 0"
      methodNode parameters do: [:p |
          varDepths at: p put: 0
      ].

      "Register method-level temps at depth 0"
      methodNode temporaries do: [:t |
          varDepths at: t put: 0
      ].

      "Walk method statements at depth 0"
      methodNode statements do: [:stmt |
          self walkStmtForCaptures: stmt depth: 0 varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames
      ].

      "Collect variables that need cells: captured AND assigned in nested block"
      capturedNames keysAndValuesDo: [:name :val |
          (assignedNestedNames includesKey: name) ifTrue: [
              result at: name put: true
          ]
      ].

      ^result
  ]

  method: walkExprForCaptures: expr depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames [
      "Walk an expression looking for variable captures and assignments."
      expr isNil ifTrue: [^self].

      expr isVariable ifTrue: [
          | name |
          name := expr name.
          (varDepths includesKey: name) ifTrue: [
              | defDepth |
              defDepth := varDepths at: name.
              defDepth < currentDepth ifTrue: [
                  capturedNames at: name put: true
              ]
          ].
          ^self
      ].

      expr isAssignment ifTrue: [
          | name |
          name := expr variable name.
          (varDepths includesKey: name) ifTrue: [
              | defDepth |
              defDepth := varDepths at: name.
              defDepth < currentDepth ifTrue: [
                  capturedNames at: name put: true.
                  assignedNestedNames at: name put: true
              ]
          ].
          self walkExprForCaptures: expr value depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames.
          ^self
      ].

      expr isMessageSend ifTrue: [
          self walkExprForCaptures: expr receiver depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames.
          expr arguments do: [:arg |
              self walkExprForCaptures: arg depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames
          ].
          ^self
      ].

      expr isCascade ifTrue: [
          self walkExprForCaptures: expr receiver depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames.
          expr messages do: [:msg |
              msg arguments do: [:arg |
                  self walkExprForCaptures: arg depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames
              ]
          ].
          ^self
      ].

      expr isBlock ifTrue: [
          expr parameters do: [:p |
              varDepths at: p put: currentDepth + 1
          ].
          expr temporaries do: [:t |
              varDepths at: t put: currentDepth + 1
          ].
          expr statements do: [:stmt |
              self walkStmtForCaptures: stmt depth: currentDepth + 1 varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames
          ].
          ^self
      ].

      expr isLiteral ifTrue: [^self].
      expr isReturn ifTrue: [
          self walkExprForCaptures: expr expression depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames.
          ^self
      ]
  ]

  method: walkStmtForCaptures: stmt depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames [
      "Walk a statement for capture analysis."
      stmt isNil ifTrue: [^self].
      stmt isReturn ifTrue: [
          self walkExprForCaptures: stmt expression depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames.
          ^self
      ].
      self walkExprForCaptures: stmt depth: currentDepth varDepths: varDepths capturedNames: capturedNames assignedNestedNames: assignedNestedNames
  ]

  # ============================================
  # Block capture analysis
  # ============================================

  method: findCapturedVariablesIn: blockNode withEnclosing: enclosingVars [
      "Analyze a block's AST to find variables that need to be captured from
       enclosing scopes. Returns an Array of variable names in encounter order.
       Uses a Dictionary (seen) mapping name -> encounter index for dedup and ordering."
      | seen result |
      seen := Dictionary new.

      self walkBlockForCaptures: blockNode enclosing: enclosingVars seen: seen blockParams: blockNode parameters blockTemps: blockNode temporaries.

      "Convert seen dictionary to an ordered array by encounter index.
       seen maps name -> index (insertion order). Build a result array
       of the right size and place each name at its index."
      result := Array new: seen size.
      seen keysAndValuesDo: [:name :idx |
          result at: idx put: name
      ].
      ^result
  ]

  method: walkBlockForCaptures: blockNode enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps [
      "Walk a block node's statements to find references to enclosing scope variables."
      blockNode statements do: [:stmt |
          self walkStmtForBlockCaptures: stmt enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps
      ]
  ]

  method: walkExprForBlockCaptures: node enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps [
      "Walk the block body to find references to enclosing variables.
       Adds found captures to the seen dictionary (mutable, shared)."
      node isNil ifTrue: [^self].

      node isBlock ifTrue: [
          "Recurse into nested block statements - captures propagate upward"
          node statements do: [:stmt |
              self walkStmtForBlockCaptures: stmt enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps
          ].
          ^self
      ].

      node isVariable ifTrue: [
          | name |
          name := node name.
          "Check if it is from enclosing scope and not a local of this block"
          (enclosingVars includesKey: name) ifTrue: [
              (self isLocalIn: name params: params temps: blockTemps) ifFalse: [
                  (seen includesKey: name) ifFalse: [
                      seen at: name put: seen size
                  ]
              ]
          ].
          ^self
      ].

      node isAssignment ifTrue: [
          | name |
          name := node variable name.
          (enclosingVars includesKey: name) ifTrue: [
              (self isLocalIn: name params: params temps: blockTemps) ifFalse: [
                  (seen includesKey: name) ifFalse: [
                      seen at: name put: seen size
                  ]
              ]
          ].
          self walkExprForBlockCaptures: node value enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps.
          ^self
      ].

      node isMessageSend ifTrue: [
          self walkExprForBlockCaptures: node receiver enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps.
          node arguments do: [:arg |
              self walkExprForBlockCaptures: arg enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps
          ].
          ^self
      ].

      node isCascade ifTrue: [
          self walkExprForBlockCaptures: node receiver enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps.
          node messages do: [:msg |
              msg arguments do: [:arg |
                  self walkExprForBlockCaptures: arg enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps
              ]
          ].
          ^self
      ].

      node isReturn ifTrue: [
          self walkExprForBlockCaptures: node expression enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps.
          ^self
      ].

      node isLiteral ifTrue: [^self]
  ]

  method: walkStmtForBlockCaptures: stmt enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps [
      stmt isNil ifTrue: [^self].
      stmt isReturn ifTrue: [
          self walkExprForBlockCaptures: stmt expression enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps.
          ^self
      ].
      self walkExprForBlockCaptures: stmt enclosing: enclosingVars seen: seen blockParams: params blockTemps: blockTemps
  ]

  method: isLocalIn: name params: params temps: blockTemps [
      "Check if a variable name is a local param or temp of this block."
      params do: [:p | p = name ifTrue: [^true]].
      blockTemps do: [:t | t = name ifTrue: [^true]].
      ^false
  ]

  # ============================================
  # AST compilation
  # ============================================

  method: compile: node [
      "Compile an AST node."
      node accept: self
  ]

  method: visitLiteralNode: node [
      | type value |
      type := node literalType.
      value := node value.

      type = #nil ifTrue: [^self emitPushNil].
      type = #true ifTrue: [^self emitPushTrue].
      type = #false ifTrue: [^self emitPushFalse].
      type = #integer ifTrue: [^self emitPushInteger: value].
      type = #float ifTrue: [^self emitPushFloat: value].
      "String, symbol, array"
      self emitPushLiteral: value
  ]

  method: visitVariableNode: node [
      | name scope index |
      name := node name.
      scope := node scope.

      scope = #self ifTrue: [^self emitPushSelf].
      scope = #super ifTrue: [^self emitPushSelf].  "Super uses self as receiver"

      "Check local temps first"
      index := self tempIndex: name.
      index >= 0 ifTrue: [
          self emitPushTemp: index.
          "If this is a cell variable, dereference it"
          (self isCellVar: name) ifTrue: [self emitCellGet].
          ^self
      ].

      "In a block: check captured variables (for variables from enclosing scopes)"
      (inBlock and: [capturedVars notNil]) ifTrue: [
          (capturedVars includesKey: name) ifTrue: [
              self emitPushCaptured: (capturedVars at: name).
              "If this is a cell variable, dereference it"
              (self isCellVar: name) ifTrue: [self emitCellGet].
              ^self
          ]
      ].

      "In a block: try outer scope temps via home frame (for non-captured method vars)"
      inBlock ifTrue: [
          index := self outerTempIndex: name.
          index >= 0 ifTrue: [^self emitPushHomeTemp: index]
      ].

      "Try ivar"
      index := self ivarIndex: name.
      index >= 0 ifTrue: [^self emitPushIvar: index].

      "Must be global"
      self emitPushGlobal: (self addLiteral: name asSymbol)
  ]

  method: visitAssignmentNode: node [
      | varNode name index |
      varNode := node variable.
      name := varNode name.

      "Check if this is a cell variable assignment"
      (self isCellVar: name) ifTrue: [
          | localIdx |
          "Check if it's a local temp in this scope"
          localIdx := self tempIndex: name.
          localIdx >= 0 ifTrue: [
              (self isCellInitialized: name) ifFalse: [
                  "First assignment: create the cell"
                  self compile: node value.
                  self emitMakeCell.
                  self emitStoreTemp: localIdx.
                  self emitPushTemp: localIdx.
                  self emitCellGet.  "Leave the VALUE on stack"
                  self markCellInitialized: name.
                  ^self
              ].
              "Subsequent assignment: store into existing cell"
              self emitPushTemp: localIdx.  "Get cell ref"
              self compile: node value.      "Value to store"
              self emitCellSet.              "Store and leave value on stack"
              ^self
          ].

          "Check captured variables (cell variable from outer scope)"
          (inBlock and: [capturedVars notNil]) ifTrue: [
              (capturedVars includesKey: name) ifTrue: [
                  self emitPushCaptured: (capturedVars at: name).  "Get cell ref"
                  self compile: node value.                         "Value to store"
                  self emitCellSet.                                 "Store and leave value on stack"
                  ^self
              ]
          ].
      ].

      "Non-cell variable assignment (or cell not found in scope)"
      "Compile the value"
      self compile: node value.
      self emitDup.  "Assignment returns the value"

      "Store to variable"
      index := self tempIndex: name.
      index >= 0 ifTrue: [^self emitStoreTemp: index].

      "In a block: check captured variables"
      (inBlock and: [capturedVars notNil]) ifTrue: [
          (capturedVars includesKey: name) ifTrue: [
              ^self emitStoreCaptured: (capturedVars at: name)
          ]
      ].

      "Try outer scope temps (for blocks assigning method variables without captures)"
      inBlock ifTrue: [
          index := self outerTempIndex: name.
          index >= 0 ifTrue: [^self emitStoreHomeTemp: index]
      ].

      index := self ivarIndex: name.
      index >= 0 ifTrue: [^self emitStoreIvar: index].

      "Global"
      self emitStoreGlobal: (self addLiteral: name asSymbol)
  ]

  method: visitMessageSendNode: node [
      | selector args |
      "Compile receiver"
      self compile: node receiver.

      "Compile arguments"
      args := node arguments.
      args do: [:arg | self compile: arg].

      "Emit send"
      selector := node selector.
      node receiver isVariable ifTrue: [
          node receiver scope = #super ifTrue: [
              ^self emitSendSuper: selector argc: args size
          ]
      ].
      self emitSend: selector argc: args size
  ]

  method: visitCascadeNode: node [
      | messages |
      "Compile receiver once"
      self compile: node receiver.

      messages := node messages.
      0 to: messages size - 1 do: [:i |
          | msg |
          msg := messages at: i.
          i < (messages size - 1) ifTrue: [self emitDup].  "Keep receiver for next message"
          msg arguments do: [:arg | self compile: arg].
          self emitSend: msg selector argc: msg arguments size.
          i < (messages size - 1) ifTrue: [self emitPop]  "Discard result except last"
      ]
  ]

  method: visitBlockNode: node [
      "Compile block as a nested method with proper variable captures."
      | blockGen blockIndex params statements newEnclosingVars varsToCapture numCaptures newCapturedVars newNestingDepth |
      blockGen := BytecodeGenerator new.

      "Share cellVars across the entire method compilation"
      blockGen setCellVars: cellVars.

      "Increment nesting depth: 0=method, 1=first block, 2+=nested blocks"
      newNestingDepth := blockNestingDepth + 1.
      blockGen setBlockNestingDepth: newNestingDepth.

      "Build enclosing variables map for this block.
       For depth-1 blocks: method temps are enclosing.
       For deeper blocks: merge current scope vars into enclosing."
      newEnclosingVars := Dictionary new.
      enclosingBlockVars notNil ifTrue: [
          enclosingBlockVars keysAndValuesDo: [:k :v | newEnclosingVars at: k put: v]
      ].
      newNestingDepth = 1 ifTrue: [
          "First-level block: method-level temps are enclosing scope"
          0 to: temps size - 1 do: [:i |
              newEnclosingVars at: (temps at: i) put: i
          ]
      ] ifFalse: [
          "Nested block: current block's temps become enclosing"
          inBlock ifTrue: [
              0 to: temps size - 1 do: [:i |
                  newEnclosingVars at: (temps at: i) put: i
              ]
          ]
      ].
      blockGen setEnclosingBlockVars: newEnclosingVars.

      "Analyze which variables this block captures from enclosing scopes"
      varsToCapture := self findCapturedVariablesIn: node withEnclosing: newEnclosingVars.
      numCaptures := varsToCapture size.

      "Build captured vars map for the block"
      newCapturedVars := Dictionary new.
      0 to: varsToCapture size - 1 do: [:i |
          newCapturedVars at: (varsToCapture at: i) put: i
      ].
      blockGen setCapturedVars: newCapturedVars.

      "Set up outer temps (empty - we use captures instead of HomeTemp for captured vars)"
      blockGen setOuterTemps: Dictionary new.

      "Add parameters as temps"
      params := node parameters.
      params do: [:p | blockGen addTemp: p].
      blockGen setBlockArity: params size.

      "Add temporaries"
      node temporaries do: [:t | blockGen addTemp: t].
      blockGen setBlockNumTemps: params size + node temporaries size.

      "Pre-initialize cell variables in block scope"
      0 to: blockGen temps size - 1 do: [:idx |
          | tName |
          tName := blockGen temps at: idx.
          (blockGen isCellVar: tName) ifTrue: [
              blockGen emitPushNil.
              blockGen emitMakeCell.
              blockGen emitStoreTemp: idx.
              blockGen emitPop.
              blockGen markCellInitialized: tName
          ]
      ].

      "Compile statements"
      statements := node statements.
      statements size > 0 ifTrue: [
          "Compile all but last statement with pop"
          0 to: statements size - 2 do: [:i |
              blockGen compile: (statements at: i).
              blockGen emitPop
          ].
          "Compile last statement without pop, then return"
          blockGen compile: (statements at: statements size - 1).
          blockGen emitBlockReturn
      ] ifFalse: [
          "Empty block returns nil"
          blockGen emitPushNil.
          blockGen emitBlockReturn
      ].

      "Add block to our list"
      blockIndex := self addBlockMethod: blockGen.

      "Emit capture instructions: push each captured variable onto the stack
       before the CREATE_BLOCK instruction."
      varsToCapture do: [:varName |
          | emitted |
          emitted := false.
          "Check if it was already captured in our scope"
          (inBlock and: [capturedVars notNil]) ifTrue: [
              (capturedVars includesKey: varName) ifTrue: [
                  self emitPushCaptured: (capturedVars at: varName).
                  emitted := true
              ]
          ].
          emitted ifFalse: [
              "It's a local temp or arg in current scope"
              | localIdx |
              localIdx := self tempIndex: varName.
              localIdx >= 0 ifTrue: [
                  self emitPushTemp: localIdx.
                  emitted := true
              ]
          ].
          emitted ifFalse: [
              "Try outer method temps via home frame"
              | outerIdx |
              outerIdx := self outerTempIndex: varName.
              outerIdx >= 0 ifTrue: [
                  self emitPushHomeTemp: outerIdx
              ]
          ]
      ].

      "Emit CREATE_BLOCK with capture count"
      self emitCreateBlock: blockIndex captures: numCaptures
  ]

  method: visitReturnNode: node [
      self compile: node expression.
      self emitReturnTop
  ]

  # ============================================
  # Method compilation
  # ============================================

  method: compileMethod: methodNode [
      "Compile a method node to bytecode."
      | params statements lastStmt hasExplicitReturn |

      "Add parameters as temps"
      params := methodNode parameters.
      params do: [:p | self addTemp: p].

      "Add temporaries"
      methodNode temporaries do: [:t | self addTemp: t].

      "Analyze which variables need cell boxing"
      cellVars := self findCellVariables: methodNode.

      "Pre-initialize cell variables for method-level args"
      params do: [:p |
          (self isCellVar: p) ifTrue: [
              | idx |
              idx := self tempIndex: p.
              self emitPushTemp: idx.   "Push current arg value"
              self emitMakeCell.         "Wrap in cell"
              self emitStoreTemp: idx.   "Store cell back"
              self emitPop.              "Clean up stack"
              self markCellInitialized: p
          ]
      ].

      "Pre-initialize cell variables for method-level temps"
      methodNode temporaries do: [:t |
          (self isCellVar: t) ifTrue: [
              | idx |
              idx := self tempIndex: t.
              self emitPushNil.
              self emitMakeCell.
              self emitStoreTemp: idx.
              self emitPop.
              self markCellInitialized: t
          ]
      ].

      "Compile statements"
      statements := methodNode statements.
      hasExplicitReturn := false.

      statements size > 0 ifTrue: [
          "Check if last statement is a return"
          lastStmt := statements at: statements size - 1.
          hasExplicitReturn := lastStmt isReturn.

          "Compile all but last statement with pop"
          0 to: statements size - 2 do: [:i |
              self compile: (statements at: i).
              self emitPop
          ].

          "Compile last statement (no pop if it's a return)"
          self compile: lastStmt.
          hasExplicitReturn ifFalse: [self emitPop]
      ].

      "Implicit return self if no explicit return"
      hasExplicitReturn ifFalse: [self emitReturnSelf].

      ^self
  ]

  # Printing
  method: printString [
      ^'BytecodeGenerator(', bytecode size printString, ' bytes, ', literals size printString, ' literals)'
  ]
