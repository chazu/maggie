# SmallInteger.mag

SmallInteger subclass: Object

  # Arithmetic (most are primitives, these are derived)
  method: negated [
      ^0 - self
  ]

  method: abs [
      self < 0 ifTrue: [^self negated].
      ^self
  ]

  method: sign [
      self < 0 ifTrue: [^-1].
      self > 0 ifTrue: [^1].
      ^0
  ]

  # Comparison
  method: max: other [
      self > other ifTrue: [^self].
      ^other
  ]

  method: min: other [
      self < other ifTrue: [^self].
      ^other
  ]

  method: between: min and: max [
      ^self >= min & (self <= max)
  ]

  # Testing
  method: even [
      ^(self \\ 2) = 0
  ]

  method: odd [
      ^self even not
  ]

  method: positive [
      ^self > 0
  ]

  method: negative [
      ^self < 0
  ]

  method: isZero [
      ^self = 0
  ]

  # Iteration
  method: timesRepeat: block [
      | count |
      count := 1.
      [count <= self] whileTrue: [
          block value.
          count := count + 1
      ]
  ]

  # Note: to:do: is implemented as a primitive
  # Do NOT define it here as a compiled method - it would override the primitive
  # and cause infinite recursion by creating new blocks on each iteration

  method: to: stop by: step do: block [
      | i |
      i := self.
      step > 0
          ifTrue: [[i <= stop] whileTrue: [block value: i. i := i + step]]
          ifFalse: [[i >= stop] whileTrue: [block value: i. i := i + step]]
  ]

  # Mathematical
  method: factorial [
      self = 0 ifTrue: [^1].
      ^self * (self - 1) factorial
  ]

  method: gcd: other [
      other = 0 ifTrue: [^self abs].
      ^other gcd: (self \\ other)
  ]

  method: lcm: other [
      ^(self * other) abs // (self gcd: other)
  ]

  # Printing
  method: printString [
      ^self primPrintString
  ]
