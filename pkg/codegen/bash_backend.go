// Package codegen provides code generation backends for Trashtalk IR.
// This file implements the Bash backend, producing compiled Bash from IR.
package codegen

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
	"time"

	"github.com/chazu/procyon/pkg/ir"
)

// BashBackend generates Bash code from Trashtalk IR.
type BashBackend struct {
	prog         *ir.Program
	buf          strings.Builder
	indent       int
	instanceVars map[string]bool // Track instance variable names for accessor generation
}

// NewBashBackend creates a new Bash code generator.
func NewBashBackend() *BashBackend {
	return &BashBackend{
		instanceVars: make(map[string]bool),
	}
}

// Generate produces Bash source code from a Trashtalk IR Program.
func (b *BashBackend) Generate(prog *ir.Program) (string, error) {
	b.prog = prog
	b.buf.Reset()
	b.indent = 0

	// Validate primitiveClass pragma constraint
	if err := b.validatePrimitiveClass(); err != nil {
		return "", err
	}

	// Build instance var lookup
	b.instanceVars = make(map[string]bool)
	for _, iv := range prog.InstanceVars {
		b.instanceVars[iv.Name] = true
	}

	// Generate header
	b.generateHeader()

	// Generate metadata variables
	b.generateMetadata()

	// Generate source embedding
	b.generateSourceEmbedding()

	// Generate instance variable accessors
	b.generateIVarAccessors()

	// Generate methods
	for _, m := range prog.Methods {
		if err := b.generateMethod(&m); err != nil {
			return "", fmt.Errorf("generating method %s: %w", m.Selector, err)
		}
	}

	return b.buf.String(), nil
}

// validatePrimitiveClass checks that a class with pragma: primitiveClass
// does not have any invalid configurations. Method type validation is no
// longer enforced since primitiveClass now allows any method type - the
// class-level pragma is sufficient to indicate native implementations exist.
func (b *BashBackend) validatePrimitiveClass() error {
	// No validation currently required for primitiveClass in bash backend.
	// The bash code in primitiveClass methods is typically simple bash that
	// works with or without DSL transformation.
	return nil
}

// generateHeader writes the file header
func (b *BashBackend) generateHeader() {
	b.writeln("#!/usr/bin/env bash")
	b.writeln("# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT")
	b.writef("# Source: %s.trash\n", b.prog.Name)
	b.writef("# Generated: %s\n", time.Now().Format("2006-01-02T15:04:05"))
	b.writeln("")
}

// generateMetadata writes class metadata variables
func (b *BashBackend) generateMetadata() {
	className := b.className()
	// Reconstruct qualified parent name if ParentPackage is set
	parent := b.prog.Parent
	if parent == "" {
		parent = "nil"
	} else if b.prog.ParentPackage != "" {
		parent = b.prog.ParentPackage + "::" + parent
	}

	// Instance vars in "name:default" format
	ivarStr := b.formatInstanceVars()

	// Traits as space-separated list
	traitsStr := strings.Join(b.prog.Traits, " ")

	// Compute source hash (placeholder - actual source would be needed)
	hash := b.computeSourceHash()

	b.writef("__%s__superclass=\"%s\"\n", className, parent)
	b.writef("__%s__instanceVars=\"%s\"\n", className, ivarStr)
	b.writef("__%s__classInstanceVars=\"\"\n", className)
	b.writef("__%s__traits=\"%s\"\n", className, traitsStr)
	b.writef("__%s__sourceHash=\"%s\"\n", className, hash)
	b.writeln("")
}

// generateSourceEmbedding writes the source embedding function
func (b *BashBackend) generateSourceEmbedding() {
	className := b.className()

	b.writef("__%s__source() {\n", className)
	b.indent++
	b.writeln("cat <<'__TRASHTALK_SOURCE_EOF__'")
	// Note: heredoc content must not have leading indentation for the terminator
	if b.prog.SourceCode != "" {
		b.buf.WriteString(b.prog.SourceCode)
		// Ensure source ends with newline
		if !strings.HasSuffix(b.prog.SourceCode, "\n") {
			b.buf.WriteString("\n")
		}
	} else {
		b.buf.WriteString("# Source not available in IR compilation mode\n")
	}
	b.buf.WriteString("__TRASHTALK_SOURCE_EOF__\n")
	b.indent--
	b.writeln("}")
	b.writeln("")
}

// generateIVarAccessors generates getter/setter methods for instance variables
func (b *BashBackend) generateIVarAccessors() {
	className := b.className()

	for _, iv := range b.prog.InstanceVars {
		// Getter: __Counter__value()
		b.writef("__%s__%s() {\n", className, iv.Name)
		b.indent++
		b.writef("echo \"$(_ivar %s)\"; return\n", iv.Name)
		b.indent--
		b.writeln("}")
		b.writeln("")

		// Setter: __Counter__value_()
		b.writef("__%s__%s_() {\n", className, iv.Name)
		b.indent++
		b.writef("_ivar_set %s \"$1\"\n", iv.Name)
		b.indent--
		b.writeln("}")
		b.writeln("")
	}
}

// generateMethod generates a single method
func (b *BashBackend) generateMethod(m *ir.Method) error {
	className := b.className()
	funcName := b.methodFuncName(m)

	b.writef("__%s__%s() {\n", className, funcName)
	b.indent++

	// For raw methods, emit the raw Bash body directly
	if m.IsRaw && m.RawBody != "" {
		// First declare parameters (raw methods still need these)
		for i, arg := range m.Args {
			b.writef("local %s=\"$%d\"\n", arg.Name, i+1)
		}
		// Write each line of the raw body with proper indentation
		lines := strings.Split(m.RawBody, "\n")
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if trimmed != "" {
				b.writef("%s\n", trimmed)
			}
		}
		b.indent--
		b.writeln("}")
		b.writeln("")
		return nil
	}

	// Declare parameters
	for i, arg := range m.Args {
		b.writef("local %s=\"$%d\"\n", arg.Name, i+1)
	}

	// Declare local variables
	if len(m.Locals) > 0 {
		var names []string
		for _, l := range m.Locals {
			names = append(names, l.Name)
		}
		b.writef("local %s\n", strings.Join(names, " "))
	}

	// Generate body statements
	for _, stmt := range m.Body {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	// If method body is empty (e.g., procyonOnly methods), emit a no-op
	// to prevent bash syntax error from empty function body
	if len(m.Body) == 0 && len(m.Args) == 0 && len(m.Locals) == 0 {
		b.writeln(":  # procyonOnly - no bash implementation")
	}

	b.indent--
	b.writeln("}")
	b.writeln("")

	return nil
}

// generateStatement generates a single statement
func (b *BashBackend) generateStatement(stmt ir.Statement) error {
	switch s := stmt.(type) {
	case *ir.AssignStmt:
		return b.generateAssign(s)
	case *ir.ReturnStmt:
		return b.generateReturn(s)
	case *ir.ExprStmt:
		return b.generateExprStmt(s)
	case *ir.IfStmt:
		return b.generateIf(s)
	case *ir.WhileStmt:
		return b.generateWhile(s)
	case *ir.ForEachStmt:
		return b.generateForEach(s)
	case *ir.BashStmt:
		return b.generateBashStmt(s)
	default:
		return fmt.Errorf("unsupported statement type: %T", stmt)
	}
}

// generateAssign generates an assignment statement
func (b *BashBackend) generateAssign(s *ir.AssignStmt) error {
	// Check for arithmetic expressions - use (( )) without subshell for Procyon compatibility
	if isArithmeticExpr(s.Value) {
		arithExpr, err := b.generateArithExpr(s.Value)
		if err != nil {
			return err
		}

		switch s.Kind {
		case ir.AssignIVar:
			// For ivars: use temp var pattern to avoid subshell
			b.writef("local __arith__; (( __arith__ = %s )); _ivar_set %s \"$__arith__\"\n", arithExpr, s.Target)
		case ir.AssignClassVar:
			// For cvars: use temp var pattern to avoid subshell
			b.writef("local __arith__; (( __arith__ = %s )); __%s__%s=\"$__arith__\"\n", arithExpr, b.className(), s.Target)
		default:
			// For locals: use (( var = expr )) directly
			b.writef("(( %s = %s ))\n", s.Target, arithExpr)
		}
		return nil
	}

	// Non-arithmetic assignment - use normal generation
	exprStr, err := b.generateExpr(s.Value)
	if err != nil {
		return err
	}

	switch s.Kind {
	case ir.AssignIVar:
		b.writef("_ivar_set %s \"%s\"\n", s.Target, exprStr)
	case ir.AssignClassVar:
		// Class variables use Bash globals with prefix
		b.writef("__%s__%s=\"%s\"\n", b.className(), s.Target, exprStr)
	default:
		// Local variable
		b.writef("%s=\"%s\"\n", s.Target, exprStr)
	}

	return nil
}

// generateReturn generates a return statement
func (b *BashBackend) generateReturn(s *ir.ReturnStmt) error {
	if s.Value == nil {
		b.writeln("return")
		return nil
	}

	exprStr, err := b.generateExpr(s.Value)
	if err != nil {
		return err
	}

	b.writef("echo \"%s\"; return\n", exprStr)
	return nil
}

// generateExprStmt generates an expression statement
func (b *BashBackend) generateExprStmt(s *ir.ExprStmt) error {
	exprStr, err := b.generateExpr(s.Expr)
	if err != nil {
		return err
	}

	// If it's a message send used as a statement (for side effects),
	// we need to strip the $() wrapper to avoid executing the return value
	if _, ok := s.Expr.(*ir.MessageSendExpr); ok {
		// Strip the $(...) wrapper if present
		if strings.HasPrefix(exprStr, "$(") && strings.HasSuffix(exprStr, ")") {
			exprStr = exprStr[2 : len(exprStr)-1]
		}
		b.writef("%s\n", exprStr)
	} else {
		// Other expressions that have side effects
		b.writef("%s\n", exprStr)
	}

	return nil
}

// generateIf generates an if statement
func (b *BashBackend) generateIf(s *ir.IfStmt) error {
	condStr, err := b.generateCondition(s.Condition)
	if err != nil {
		return err
	}

	b.writef("if %s; then\n", condStr)
	b.indent++

	for _, stmt := range s.ThenBlock {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	b.indent--

	if len(s.ElseBlock) > 0 {
		b.writeln("else")
		b.indent++
		for _, stmt := range s.ElseBlock {
			if err := b.generateStatement(stmt); err != nil {
				return err
			}
		}
		b.indent--
	}

	b.writeln("fi")
	return nil
}

// generateWhile generates a while loop
func (b *BashBackend) generateWhile(s *ir.WhileStmt) error {
	condStr, err := b.generateCondition(s.Condition)
	if err != nil {
		return err
	}

	b.writef("while %s; do\n", condStr)
	b.indent++

	for _, stmt := range s.Body {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	b.indent--
	b.writeln("done")
	return nil
}

// generateForEach generates a for-each loop
func (b *BashBackend) generateForEach(s *ir.ForEachStmt) error {
	collExpr, err := b.generateExpr(s.Collection)
	if err != nil {
		return err
	}

	b.writef("for %s in %s; do\n", s.IterVar, collExpr)
	b.indent++

	for _, stmt := range s.Body {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	b.indent--
	b.writeln("done")
	return nil
}

// generateBashStmt generates raw Bash code
func (b *BashBackend) generateBashStmt(s *ir.BashStmt) error {
	// Raw bash code is written directly
	b.writef("%s\n", s.Code)
	return nil
}

// generateCondition generates a bash condition expression
func (b *BashBackend) generateCondition(expr ir.Expression) (string, error) {
	switch e := expr.(type) {
	case *ir.BinaryExpr:
		left, err := b.generateExpr(e.Left)
		if err != nil {
			return "", err
		}
		right, err := b.generateExpr(e.Right)
		if err != nil {
			return "", err
		}

		// Map operators to bash test operators
		switch e.Op {
		case "==":
			return fmt.Sprintf("[[ \"$%s\" == \"%s\" ]]", stripDollar(left), right), nil
		case "!=":
			return fmt.Sprintf("[[ \"$%s\" != \"%s\" ]]", stripDollar(left), right), nil
		case "<":
			return fmt.Sprintf("(( $%s < %s ))", stripDollar(left), right), nil
		case ">":
			return fmt.Sprintf("(( $%s > %s ))", stripDollar(left), right), nil
		case "<=":
			return fmt.Sprintf("(( $%s <= %s ))", stripDollar(left), right), nil
		case ">=":
			return fmt.Sprintf("(( $%s >= %s ))", stripDollar(left), right), nil
		default:
			return fmt.Sprintf("[[ %s %s %s ]]", left, e.Op, right), nil
		}
	case *ir.LiteralExpr:
		// Boolean literal
		if e.Type_ == ir.TypeBool {
			if v, ok := e.Value.(bool); ok && v {
				return "true", nil
			}
			return "false", nil
		}
		return b.generateExpr(expr)
	case *ir.JSONPrimitiveExpr:
		// JSON primitives that return "true"/"false" strings need special handling
		exprStr, err := b.generateExpr(expr)
		if err != nil {
			return "", err
		}
		if e.Operation == "objectHasKey" || e.Operation == "objectIsEmpty" || e.Operation == "arrayIsEmpty" {
			// Compare against "true" string since jq outputs true/false as strings
			return fmt.Sprintf("[[ \"%s\" == \"true\" ]]", exprStr), nil
		}
		// For other JSON primitives, use -n test
		return fmt.Sprintf("[[ -n \"%s\" ]]", exprStr), nil
	case *ir.MessageSendExpr:
		// Check for predicate selectors that should compile to bash tests
		if testOp, isPredicate := bashPredicateTest(e.Selector); isPredicate {
			// Generate the receiver as the subject of the test
			subject, err := b.generateExpr(e.Receiver)
			if err != nil {
				return "", err
			}
			subjectVar := stripDollar(subject)
			return fmt.Sprintf("[[ %s \"$%s\" ]]", testOp, subjectVar), nil
		}
		// Non-predicate message send - generate and wrap in -n test
		exprStr, err := b.generateExpr(expr)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[[ -n \"%s\" ]]", exprStr), nil
	default:
		// For other expressions, wrap in test
		exprStr, err := b.generateExpr(expr)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[[ -n \"%s\" ]]", exprStr), nil
	}
}

// generateExpr generates an expression and returns its string representation
func (b *BashBackend) generateExpr(expr ir.Expression) (string, error) {
	switch e := expr.(type) {
	case *ir.LiteralExpr:
		return b.generateLiteral(e)
	case *ir.VarRefExpr:
		return b.generateVarRef(e)
	case *ir.BinaryExpr:
		return b.generateBinaryExpr(e)
	case *ir.UnaryExpr:
		return b.generateUnaryExpr(e)
	case *ir.MessageSendExpr:
		return b.generateMessageSend(e)
	case *ir.BlockExpr:
		return b.generateBlockExpr(e)
	case *ir.SubshellExpr:
		return b.generateSubshell(e)
	case *ir.SelfExpr:
		return "$_RECEIVER", nil
	case *ir.ClassRefExpr:
		return e.FullName(), nil
	case *ir.JSONPrimitiveExpr:
		return b.generateJSONPrimitive(e)
	case *ir.ClassPrimitiveExpr:
		return b.generateClassPrimitive(e)
	default:
		return "", fmt.Errorf("unsupported expression type: %T", expr)
	}
}

// generateLiteral generates a literal value
func (b *BashBackend) generateLiteral(e *ir.LiteralExpr) (string, error) {
	switch e.Type_ {
	case ir.TypeInt:
		return fmt.Sprintf("%v", e.Value), nil
	case ir.TypeString:
		return fmt.Sprintf("%v", e.Value), nil
	case ir.TypeBool:
		if v, ok := e.Value.(bool); ok && v {
			return "true", nil
		}
		return "false", nil
	case ir.TypeJSON:
		// JSON values need to be properly quoted
		return fmt.Sprintf("%v", e.Value), nil
	default:
		return fmt.Sprintf("%v", e.Value), nil
	}
}

// generateVarRef generates a variable reference
func (b *BashBackend) generateVarRef(e *ir.VarRefExpr) (string, error) {
	switch e.Kind {
	case ir.VarIVar:
		return fmt.Sprintf("$(_ivar %s)", e.Name), nil
	case ir.VarClassVar:
		return fmt.Sprintf("${__%s__%s}", b.className(), e.Name), nil
	case ir.VarLocal, ir.VarParam:
		return fmt.Sprintf("$%s", e.Name), nil
	case ir.VarGlobal:
		return fmt.Sprintf("$%s", e.Name), nil
	default:
		return fmt.Sprintf("$%s", e.Name), nil
	}
}

// generateBinaryExpr generates a binary expression
func (b *BashBackend) generateBinaryExpr(e *ir.BinaryExpr) (string, error) {
	// Handle string concatenation specially - collect all parts first
	if e.Op == "," {
		return b.generateStringConcat(e)
	}

	left, err := b.generateExpr(e.Left)
	if err != nil {
		return "", err
	}
	right, err := b.generateExpr(e.Right)
	if err != nil {
		return "", err
	}

	// Arithmetic operations use $((...))
	switch e.Op {
	case "+", "-", "*", "/", "%":
		return fmt.Sprintf("$(( %s %s %s ))", left, e.Op, right), nil
	case "==", "!=", "<", ">", "<=", ">=":
		// Comparison in arithmetic context
		return fmt.Sprintf("$(( %s %s %s ))", left, e.Op, right), nil
	case "&&", "||":
		return fmt.Sprintf("%s %s %s", left, e.Op, right), nil
	default:
		return fmt.Sprintf("%s %s %s", left, e.Op, right), nil
	}
}

// generateStringConcat handles string concatenation with the comma operator.
// It collects all parts and joins them properly for bash.
// The result is the content (without outer quotes) - the caller adds quotes.
func (b *BashBackend) generateStringConcat(e *ir.BinaryExpr) (string, error) {
	var parts []concatPart
	b.collectConcatParts(e, &parts)

	var result strings.Builder

	for _, part := range parts {
		if part.isLiteral {
			// String literal: escape internal double quotes
			escaped := strings.ReplaceAll(part.value, "\"", "\\\"")
			result.WriteString(escaped)
		} else if strings.HasPrefix(part.value, "$") {
			// Variable or command substitution
			varExpr := part.value[1:]
			if strings.HasPrefix(varExpr, "(") {
				// Command substitution like $(_ivar foo) - use as-is
				result.WriteString(part.value)
			} else {
				// Simple variable - wrap in ${} for safe interpolation
				result.WriteString("${" + varExpr + "}")
			}
		} else {
			// Other expressions - include as-is
			result.WriteString(part.value)
		}
	}

	return result.String(), nil
}

// concatPart represents a part of a string concatenation
type concatPart struct {
	value     string
	isLiteral bool // true if this came from a string literal
}

// collectConcatParts recursively collects parts of a concatenation expression.
func (b *BashBackend) collectConcatParts(expr ir.Expression, parts *[]concatPart) {
	if binExpr, ok := expr.(*ir.BinaryExpr); ok && binExpr.Op == "," {
		b.collectConcatParts(binExpr.Left, parts)
		b.collectConcatParts(binExpr.Right, parts)
		return
	}

	// Check if this is a string literal
	if lit, ok := expr.(*ir.LiteralExpr); ok && lit.Type_ == ir.TypeString {
		// String literals come without quotes, just the content
		*parts = append(*parts, concatPart{value: fmt.Sprintf("%v", lit.Value), isLiteral: true})
		return
	}

	// Generate this expression and add to parts
	partStr, err := b.generateExpr(expr)
	if err != nil {
		*parts = append(*parts, concatPart{value: "", isLiteral: false})
		return
	}
	*parts = append(*parts, concatPart{value: partStr, isLiteral: false})
}

// generateUnaryExpr generates a unary expression
func (b *BashBackend) generateUnaryExpr(e *ir.UnaryExpr) (string, error) {
	operand, err := b.generateExpr(e.Operand)
	if err != nil {
		return "", err
	}

	switch e.Op {
	case "!":
		return fmt.Sprintf("! %s", operand), nil
	case "-":
		return fmt.Sprintf("$(( -%s ))", operand), nil
	default:
		return fmt.Sprintf("%s%s", e.Op, operand), nil
	}
}

// generateMessageSend generates a message send expression
func (b *BashBackend) generateMessageSend(e *ir.MessageSendExpr) (string, error) {
	var receiver string
	var err error

	if e.IsSelfSend {
		receiver = "\"$_RECEIVER\""
	} else if e.IsClassSend {
		receiver = e.TargetClass
	} else {
		receiver, err = b.generateExpr(e.Receiver)
		if err != nil {
			return "", err
		}
		// Wrap in quotes if it's a variable
		if strings.HasPrefix(receiver, "$") {
			receiver = fmt.Sprintf("\"%s\"", receiver)
		}
	}

	// Build selector (replace : with _)
	selector := selectorToBashName(e.Selector)

	// Build args - all arguments must be quoted to prevent word splitting
	var args []string
	for _, arg := range e.Args {
		argStr, err := b.generateExpr(arg)
		if err != nil {
			return "", err
		}
		// Quote variables and expressions to prevent word splitting
		// Skip quoting if already quoted or is a literal without special chars
		if needsQuoting(argStr) {
			argStr = fmt.Sprintf("\"%s\"", argStr)
		}
		args = append(args, argStr)
	}

	if len(args) > 0 {
		return fmt.Sprintf("$(@ %s %s %s)", receiver, selector, strings.Join(args, " ")), nil
	}
	return fmt.Sprintf("$(@ %s %s)", receiver, selector), nil
}

// generateBlockExpr generates a block/closure expression
func (b *BashBackend) generateBlockExpr(e *ir.BlockExpr) (string, error) {
	// If the block has a single expression statement, extract and evaluate it
	// This is common for condition blocks like [i < len]
	if len(e.Body) == 1 {
		if exprStmt, ok := e.Body[0].(*ir.ExprStmt); ok {
			return b.generateExpr(exprStmt.Expr)
		}
	}

	// For more complex blocks, generate inline bash code
	var stmts []string
	for _, stmt := range e.Body {
		// Save current buffer state and use a temporary one
		origBuf := b.buf
		b.buf = strings.Builder{}

		if err := b.generateStatement(stmt); err != nil {
			b.buf = origBuf
			return "", err
		}

		stmtCode := strings.TrimSpace(b.buf.String())
		b.buf = origBuf

		if stmtCode != "" {
			stmts = append(stmts, stmtCode)
		}
	}

	if len(stmts) == 0 {
		return ":", nil // no-op
	}

	return strings.Join(stmts, "; "), nil
}

// generateSubshell generates a subshell expression
func (b *BashBackend) generateSubshell(e *ir.SubshellExpr) (string, error) {
	return fmt.Sprintf("$(%s)", e.Code), nil
}

// generateJSONPrimitive generates a JSON primitive operation
func (b *BashBackend) generateJSONPrimitive(e *ir.JSONPrimitiveExpr) (string, error) {
	receiver, err := b.generateExpr(e.Receiver)
	if err != nil {
		return "", err
	}

	switch e.Operation {
	case "arrayAt":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("arrayAt requires index argument")
		}
		idx, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -r --argjson i \"%s\" '.[$i] // empty')", receiver, idx), nil

	case "arrayPush":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("arrayPush requires value argument")
		}
		val, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --arg v \"%s\" '. + [$v]')", receiver, val), nil

	case "arrayLength":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length')", receiver), nil

	case "arrayFirst":
		return fmt.Sprintf("$(echo \"%s\" | jq -r '.[0] // empty')", receiver), nil

	case "arrayLast":
		return fmt.Sprintf("$(echo \"%s\" | jq -r '.[-1] // empty')", receiver), nil

	case "arrayAtPut":
		if len(e.Args) < 2 {
			return "", fmt.Errorf("arrayAtPut requires index and value arguments")
		}
		idx, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		val, err := b.generateExpr(e.Args[1])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --argjson i \"%s\" --arg v \"%s\" '.[$i] = $v')", receiver, idx, val), nil

	case "arrayRemoveAt":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("arrayRemoveAt requires index argument")
		}
		idx, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --argjson i \"%s\" 'del(.[$i])')", receiver, idx), nil

	case "objectAt":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("objectAt requires key argument")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -r --arg k \"%s\" '.[$k] // empty')", receiver, key), nil

	case "objectAtPut":
		if len(e.Args) < 2 {
			return "", fmt.Errorf("objectAtPut requires key and value arguments")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		val, err := b.generateExpr(e.Args[1])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --arg k \"%s\" --arg v \"%s\" '. + {($k): $v}')", receiver, key, val), nil

	case "arrayIsEmpty":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length == 0')", receiver), nil

	case "objectLength":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length')", receiver), nil

	case "objectIsEmpty":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length == 0')", receiver), nil

	case "objectHasKey":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("objectHasKey requires key argument")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -r --arg k \"%s\" 'has($k)')", receiver, key), nil

	case "objectKeys":
		return fmt.Sprintf("$(echo \"%s\" | jq -c 'keys')", receiver), nil

	case "objectValues":
		return fmt.Sprintf("$(echo \"%s\" | jq -c '[.[]]')", receiver), nil

	case "objectRemoveKey":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("objectRemoveKey requires key argument")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --arg k \"%s\" 'del(.[$k])')", receiver, key), nil

	default:
		return "", fmt.Errorf("unsupported JSON operation: %s", e.Operation)
	}
}

// generateClassPrimitive generates Bash code for class primitive operations
// by falling back to message sends to the Bash runtime
func (b *BashBackend) generateClassPrimitive(e *ir.ClassPrimitiveExpr) (string, error) {
	// Map operation names back to selectors
	var selector string
	switch e.Operation {
	// String operations
	case "stringIsEmpty":
		selector = "isEmpty:"
	case "stringNotEmpty":
		selector = "notEmpty:"
	case "stringContains":
		selector = "contains:substring:"
	case "stringStartsWith":
		selector = "startsWith:prefix:"
	case "stringEndsWith":
		selector = "endsWith:suffix:"
	case "stringEquals":
		selector = "equals:to:"
	case "stringTrimPrefix":
		selector = "trimPrefix:from:"
	case "stringTrimSuffix":
		selector = "trimSuffix:from:"
	case "stringReplace":
		selector = "replace:with:in:"
	case "stringReplaceAll":
		selector = "replaceAll:with:in:"
	case "stringSubstring":
		selector = "substring:from:length:"
	case "stringLength":
		selector = "length:"
	case "stringUppercase":
		selector = "uppercase:"
	case "stringLowercase":
		selector = "lowercase:"
	case "stringTrim":
		selector = "trim:"
	case "stringConcat":
		selector = "concat:with:"

	// File operations
	case "fileExists":
		selector = "exists:"
	case "fileIsFile":
		selector = "isFile:"
	case "fileIsDirectory":
		selector = "isDirectory:"
	case "fileIsSymlink":
		selector = "isSymlink:"
	case "fileIsFifo":
		selector = "isFifo:"
	case "fileIsSocket":
		selector = "isSocket:"
	case "fileIsBlockDevice":
		selector = "isBlockDevice:"
	case "fileIsCharDevice":
		selector = "isCharDevice:"
	case "fileIsReadable":
		selector = "isReadable:"
	case "fileIsWritable":
		selector = "isWritable:"
	case "fileIsExecutable":
		selector = "isExecutable:"
	case "fileIsEmpty":
		selector = "isEmpty:"
	case "fileNotEmpty":
		selector = "notEmpty:"
	case "fileIsNewer":
		selector = "isNewer:than:"
	case "fileIsOlder":
		selector = "isOlder:than:"
	case "fileIsSame":
		selector = "isSame:as:"

	default:
		return "", fmt.Errorf("unsupported class primitive operation: %s", e.Operation)
	}

	// Generate args
	var args []string
	for _, arg := range e.Args {
		argStr, err := b.generateExpr(arg)
		if err != nil {
			return "", err
		}
		args = append(args, fmt.Sprintf("\"%s\"", argStr))
	}

	// Generate message send: $(@ ClassName selector args...)
	bashSelector := selectorToBashName(selector)
	if len(args) > 0 {
		return fmt.Sprintf("$(@ %s %s %s)", e.ClassName, bashSelector, strings.Join(args, " ")), nil
	}
	return fmt.Sprintf("$(@ %s %s)", e.ClassName, bashSelector), nil
}

// Helper methods

// className returns the class name for function naming
func (b *BashBackend) className() string {
	if b.prog.Package != "" {
		return b.prog.Package + "__" + b.prog.Name
	}
	return b.prog.Name
}

// methodFuncName converts a method to its Bash function name suffix
func (b *BashBackend) methodFuncName(m *ir.Method) string {
	selector := selectorToBashName(m.Selector)

	if m.Kind == ir.ClassMethod {
		return "class__" + selector
	}
	return selector
}

// selectorToBashName converts a selector like "at:put:" to "at_put_"
func selectorToBashName(selector string) string {
	return strings.ReplaceAll(selector, ":", "_")
}

// formatInstanceVars formats instance variables for metadata
func (b *BashBackend) formatInstanceVars() string {
	var parts []string
	for _, iv := range b.prog.InstanceVars {
		defaultVal := ""
		if iv.Default.Raw != "" {
			defaultVal = iv.Default.Raw
		}
		parts = append(parts, fmt.Sprintf("%s:%s", iv.Name, defaultVal))
	}
	return strings.Join(parts, " ")
}

// computeSourceHash computes a SHA-256 hash of the source code
func (b *BashBackend) computeSourceHash() string {
	// Hash the actual source code if available
	if b.prog.SourceCode != "" {
		hash := sha256.Sum256([]byte(b.prog.SourceCode))
		return hex.EncodeToString(hash[:])
	}
	// Fallback: hash the program structure
	data := fmt.Sprintf("%s%s%v", b.prog.Name, b.prog.Parent, b.prog.Traits)
	hash := sha256.Sum256([]byte(data))
	return hex.EncodeToString(hash[:])
}

// writeln writes a line with current indentation
func (b *BashBackend) writeln(s string) {
	b.buf.WriteString(strings.Repeat("  ", b.indent))
	b.buf.WriteString(s)
	b.buf.WriteString("\n")
}

// writef writes a formatted string with current indentation
func (b *BashBackend) writef(format string, args ...interface{}) {
	b.buf.WriteString(strings.Repeat("  ", b.indent))
	fmt.Fprintf(&b.buf, format, args...)
}

// stripDollar removes the leading $ from a variable reference
func stripDollar(s string) string {
	if strings.HasPrefix(s, "$") {
		return s[1:]
	}
	return s
}

// bashPredicateTest maps predicate selectors to bash test operators.
// Returns (testOp, true) if the selector is a predicate, ("", false) otherwise.
// Predicate selectors are unary messages that should compile to [[ testOp "$var" ]]
// instead of method calls.
func bashPredicateTest(selector string) (string, bool) {
	predicates := map[string]string{
		// String/variable tests
		"isEmpty":  "-z",
		"notEmpty": "-n",
		// File tests
		"fileExists":   "-e",
		"isFile":       "-f",
		"isDirectory":  "-d",
		"isFifo":       "-p",
		"isSymlink":    "-L",
		"isReadable":   "-r",
		"isWritable":   "-w",
		"isExecutable": "-x",
	}
	if op, ok := predicates[selector]; ok {
		return op, true
	}
	return "", false
}

// isArithmeticExpr returns true if the expression is an arithmetic operation
func isArithmeticExpr(expr ir.Expression) bool {
	switch e := expr.(type) {
	case *ir.BinaryExpr:
		switch e.Op {
		case "+", "-", "*", "/", "%":
			return true
		}
	case *ir.UnaryExpr:
		if e.Op == "-" {
			return true
		}
	}
	return false
}

// generateArithExpr generates an arithmetic expression without the $(( )) wrapper
// This is used inside (( )) commands for Procyon compatibility
func (b *BashBackend) generateArithExpr(expr ir.Expression) (string, error) {
	switch e := expr.(type) {
	case *ir.BinaryExpr:
		left, err := b.generateArithExpr(e.Left)
		if err != nil {
			return "", err
		}
		right, err := b.generateArithExpr(e.Right)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(%s %s %s)", left, e.Op, right), nil
	case *ir.UnaryExpr:
		operand, err := b.generateArithExpr(e.Operand)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(-%s)", operand), nil
	case *ir.VarRefExpr:
		switch e.Kind {
		case ir.VarIVar:
			return fmt.Sprintf("$(_ivar %s)", e.Name), nil
		case ir.VarClassVar:
			return fmt.Sprintf("${__%s__%s}", b.className(), e.Name), nil
		default:
			return fmt.Sprintf("$%s", e.Name), nil
		}
	case *ir.LiteralExpr:
		return fmt.Sprintf("%v", e.Value), nil
	default:
		// Fall back to regular expression generation
		return b.generateExpr(expr)
	}
}

// needsQuoting returns true if the argument string needs to be quoted
// to prevent word splitting in bash
func needsQuoting(s string) bool {
	// Already quoted
	if strings.HasPrefix(s, "\"") && strings.HasSuffix(s, "\"") {
		return false
	}
	// Variable references and subshells need quoting to prevent word splitting
	// Even $(...) subshells can return empty strings or strings with spaces
	if strings.HasPrefix(s, "$") {
		return true
	}
	// Simple numeric literals don't need quoting
	if isNumericLiteral(s) {
		return false
	}
	// Check for characters that need quoting
	for _, c := range s {
		if c == ' ' || c == '\t' || c == '\n' || c == '*' || c == '?' {
			return true
		}
	}
	// Simple word-like strings (alphanumeric, underscore, hyphen) don't need quoting
	isSimple := true
	for _, c := range s {
		if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_' || c == '-' || c == '.') {
			isSimple = false
			break
		}
	}
	return !isSimple
}

// isNumericLiteral returns true if the string is a simple numeric literal
func isNumericLiteral(s string) bool {
	if len(s) == 0 {
		return false
	}
	start := 0
	if s[0] == '-' || s[0] == '+' {
		start = 1
	}
	if start >= len(s) {
		return false
	}
	for i := start; i < len(s); i++ {
		if s[i] < '0' || s[i] > '9' {
			return false
		}
	}
	return true
}
